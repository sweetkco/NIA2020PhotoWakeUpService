/**
 * Generated by Verge3D Puzzles v.3.5.0 pre4
 * Mon Nov 23 2020 16:47:42 GMT+0400 (Volgograd Standard Time)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function() {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.objClickInfo = [];
_pGlob.pickedObject = '';
_pGlob.objHoverInfo = [];
_pGlob.hoveredObject = '';
_pGlob.objMovementInfos = {};
_pGlob.objDragOverCallbacks = [];
_pGlob.objDragOverInfoByBlock = {}
_pGlob.dragMoveOrigins = {};
_pGlob.dragScaleOrigins = {};
_pGlob.mediaElements = {};
_pGlob.loadedFiles = {};
_pGlob.loadedFile = '';
_pGlob.promiseValue = '';
_pGlob.animMixerCallbacks = [];
_pGlob.arHitPoint = new v3d.Vector3(0, 0, 0);
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.animateParamUpdate = null;
_pGlob.openedFile = '';
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.gamepadIndex = 0;

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster();
_pGlob.intervals = {};

var _pPhysics = {};

_pPhysics.tickCallbacks = [];
_pPhysics.syncList = [];
_pPhysics.consList = [];

// internal info
_pPhysics.collisionData = [];

// goes to collision callback
_pPhysics.collisionInfo = {
    objectA: '',
    objectB: '',
    distance: 0,
    positionOnA: [0, 0, 0],
    positionOnB: [0, 0, 0],
    normalOnB: [0, 0, 0]
};

var _noWebAudioReported = false;

var PL = v3d.PL = v3d.PL || {};

// a more readable alias for PL (stands for "Puzzle Logic")
v3d.puzzles = PL;

PL.procedures = PL.procedures || {};

_pGlob.wooProductInfo = {};

PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    var PROC = {
    
};


// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// setCSSRuleStyle puzzle
function setCSSRuleStyle(prop, value, id, isParent, mediaRule) {
    var styles = (isParent) ? parent.document.styleSheets : document.styleSheets;
    for (var i = 0; i < styles.length; i++) {
        /**
         * workaround for "DOMException: Failed to read the 'cssRules' property
         * from 'CSSStyleSheet': Cannot access rules"
         */
        try { var cssRules = styles[i].cssRules; }
        catch (e) { continue; }

        for (var j = 0; j < cssRules.length; j++) {
            var cssRule = cssRules[j];
            if (!mediaRule && cssRule.selectorText == id)
                cssRule.style[prop] = value;
            else if (mediaRule && cssRule.media && cssRule.media.mediaText == mediaRule) {
                var cssRulesMedia = cssRule.cssRules;
                for (var k = 0; k < cssRulesMedia.length; k++) {
                    if (cssRulesMedia[k].selectorText == id)
                        cssRulesMedia[k].style[prop] = value;
                }
            }
        }
    }
}




// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = true;

setCSSRuleStyle('backgroundImage', 'url(\'./media/preloader-icon.svg\')', '.v3d-simple-preloader-logo', false,'');
setCSSRuleStyle('background', 'rgba(236,108,0,1)', '.v3d-simple-preloader-bar', false,'');
setCSSRuleStyle('border', 'none', '.v3d-simple-preloader-bar', false,'');
setCSSRuleStyle('height', '8px', '.v3d-simple-preloader-bar', false,'');
setCSSRuleStyle('borderBottom', '4px solid black', '.v3d-simple-preloader-bar', false,'');
setCSSRuleStyle('borderRight', '4px solid black', '.v3d-simple-preloader-bar', false,'');

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {
initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["interface_recalc"] = interface_recalc;
this.procedures["rotate_your_device_message"] = rotate_your_device_message;
this.procedures["car_repair"] = car_repair;
this.procedures["map_range"] = map_range;
this.procedures["respawn"] = respawn;
this.procedures["engine_force_recalc"] = engine_force_recalc;
this.procedures["damage_map_update"] = damage_map_update;
this.procedures["recalculate_checkpoint"] = recalculate_checkpoint;
this.procedures["race_restart"] = race_restart;
this.procedures["press_r_or_bouble_tap"] = press_r_or_bouble_tap;
this.procedures["change_track"] = change_track;
this.procedures["random_track_number"] = random_track_number;

var PROC = {
    "interface_recalc": interface_recalc,
    "rotate_your_device_message": rotate_your_device_message,
    "car_repair": car_repair,
    "map_range": map_range,
    "respawn": respawn,
    "engine_force_recalc": engine_force_recalc,
    "damage_map_update": damage_map_update,
    "recalculate_checkpoint": recalculate_checkpoint,
    "race_restart": race_restart,
    "press_r_or_bouble_tap": press_r_or_bouble_tap,
    "change_track": change_track,
    "random_track_number": random_track_number,
};

var game_started, sound_breaking_skid, steeringIncrement_multiplier, steeringIncrement, actions, camera_moving_speed, help_shown, dead_zone_start, building_collisions, repair_shop_start, paint_shop_green_start, buildings, barrel_hit_start, static_props_collisions, tyres, furniture_hit_start, cacti_hit_start, traffic_cone_hit_start, cacti_mesh, sound_glass_crash, list_of_speed_current, respawn_in_action, input_range_start, input_range_end, result_range_start, result_range_end, input_value, summ_damage, for_damage_list, front_damage_start, respawn_set, car_body_hit_start, playground_props, gates, gates_hit_start, touch_1_busy, mono_rotate_on, track_1, sound_base_engine, steeringClamp, screen_ratio, paint_shop_orange_start, bl_j, paint_shop_blue_start, barrels, static_props, pl_i, furniture, cacti_capsule, traffic_cones, sound_front_crash, list_of_speed, result_range, output_value, front_damaged, front_right_damage_start, front_left_damage_start, car_down, car_drop_start, rear_damage_start, rear_right_damage_start, rear_left_damge_start, gt_i, race_started, next_checkpoint, current_checkpoint, checkpoint_touch_start, maxBreakingForce_multiplier, track_2, random_number, maxEngineForce, j, sound_right_crash, car_stopped, front_right_damaged, front_left_damaged, checkpoint_seconds, start_counter, track_3, maxBreakingForce, sound_left_crash, list_of_height, car_x_rotation, car_speed, checkpoint_minutes, press_r, current_track, syncVehicleCallback, car_falling, rear_damaged, rear_right_damaged, car_y_rotation, no_count, current_track_number, moving_side, list_of_speed_i, list_of_height_current, rear_left_damaged, checkpoint_total_time, touch_1_base_x, touch_1_x_length, car_height, touch_2_base_x, touch_2_x_length, list_of_height_i, touch_1_base_y, touch_1_y_length;


function setScreenScale(factor) {
    appInstance.renderer.setPixelRatio(factor);
    // to update possible post-processing passes
    appInstance.onResize();
}




// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return (obj.type !== "AmbientLight" && obj.name !== ""
            && !(obj.isMesh && obj.isMaterialGeneratedMesh));
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    appInstance.scene.traverse(function(obj) {
        if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
            objFound = obj;
            if (runTime) {
                _pGlob.objCache[objName] = objFound;
            }
        }
    });
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc;
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}





/**
 * Retrieve coordinate system from the loaded scene
 */
function getCoordSystem() {
    var scene = appInstance.scene;

    if (scene && "v3d" in scene.userData && "coordSystem" in scene.userData.v3d) {
        return scene.userData.v3d.coordSystem;
    } else {
        // COMPAT: <2.17, consider replacing to 'Y_UP_RIGHT' for scenes with unknown origin
        return 'Z_UP_RIGHT';
    }
}


/**
 * Transform coordinates from one space to another
 * Can be used with Vector3 or Euler.
 */
function coordsTransform(coords, from, to, noSignChange) {

    if (from == to)
        return coords;

    var y = coords.y, z = coords.z;

    if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
    } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
    } else {
        console.error('coordsTransform: Unsupported coordinate space');
    }

    return coords;
}


/**
 * Verge3D euler rotation to Blender/Max shortest.
 * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
 *    order) via reversion: XYZ -> ZYX
 * 2) swizzle ZYX->YZX
 * 3) choose the shortest rotation to resemble Blender's behavior
 */
var eulerV3DToBlenderShortest = function() {

    var eulerTmp = new v3d.Euler();
    var eulerTmp2 = new v3d.Euler();
    var vec3Tmp = new v3d.Vector3();

    return function(euler, dest) {

        var eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        var eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        var len = eulerBlender.toVector3(vec3Tmp).lengthSq();
        var lenAlt = eulerBlenderAlt.toVector3(vec3Tmp).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
    }

}();




// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = coordsTransform(worldPos, getCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = appInstance.camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = coordsTransform(worldTarget, getCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (appInstance.camera.parent) {
            appInstance.camera.parent.worldToLocal(worldPos);
        }
        appInstance.camera.position.copy(worldPos);
        appInstance.camera.lookAt(worldTarget);
        doSlot();
    }
}



// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function initObjectPicking(callback, eventType, mouseDownUseTouchStart, mouseButtons) {

    var elem = appInstance.renderer.domElement;
    elem.addEventListener(eventType, pickListener);

    if (eventType == 'mousedown') {

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, pickListener);

    } else if (eventType == 'dblclick') {

        var prevTapTime = 0;

        function doubleTapCallback(event) {

            var now = new Date().getTime();
            var timesince = now - prevTapTime;

            if (timesince < 600 && timesince > 0) {

                pickListener(event);
                prevTapTime = 0;
                return;

            }

            prevTapTime = new Date().getTime();
        }

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, doubleTapCallback);
    }

    var raycaster = new v3d.Raycaster();

    function pickListener(event) {
        event.preventDefault();

        var xNorm = 0, yNorm = 0;
        if (event instanceof MouseEvent) {
            if (mouseButtons && mouseButtons.indexOf(event.button) == -1)
                return;
            xNorm = event.offsetX / elem.clientWidth;
            yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
            var rect = elem.getBoundingClientRect();
            xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
            yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(_pGlob.screenCoords, appInstance.camera);
        var objList = [];
        appInstance.scene.traverse(function(obj){objList.push(obj);});
        var intersects = raycaster.intersectObjects(objList);
        callback(intersects, event);
    }
}

function objectsIncludeObj(objNames, testedObjName) {
    if (!testedObjName) return false;

    for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
            return true;
        } else {
            // also check children which are auto-generated for multi-material objects
            var obj = getObjectByName(objNames[i]);
            if (obj && obj.type == "Group") {
                for (var j = 0; j < obj.children.length; j++) {
                    if (testedObjName == obj.children[j].name) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

// utility function used by the whenClicked, whenHovered, whenDraggedOver, and raycast puzzles
function getPickedObjectName(obj) {
    // auto-generated from a multi-material object, use parent name instead
    if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
    } else {
        return obj.name;
    }
}



function AudioWebAudio() {
    this.audio = new v3d.Audio(new v3d.AudioListener());

    this._muted = false;
    this._volume = 1;
}

Object.assign(AudioWebAudio.prototype, {

    load: function(url) {
        var scope = this;

        var xhr = new XMLHttpRequest()
        xhr.open('GET', url);
        xhr.responseType = 'arraybuffer';

        xhr.onload = function(e) {
            if (this.status === 200) {
                // new promise-based syntax is not currently supported in Safari
                scope.audio.context.decodeAudioData(this.response, function(decodedData) {
                    scope.audio.setBuffer(decodedData);
                });
            }
        }

        xhr.send();
        return this;
    },

    play: function() {
        if (this.audio.buffer === null) return;
        this.audio.play();
    },

    pause: function() {
        this.audio.pause();
    },

    stop: function() {
        if (this.audio.buffer === null) return;
        this.audio.stop();
    },

    rewind: function() {
        if (this.audio.buffer === null) return;

        var isPlaying = this.audio.isPlaying;
        this.audio.stop();
        if (isPlaying) {
            this.audio.play();
        }
    },

    setPlaybackRate: function(rate) {
        this.audio.setPlaybackRate(rate);
    },

    isPlaying: function() {
        return this.audio.isPlaying;
    },

    setLoop: function(looped) {
        this.audio.setLoop(looped);
    },

    setVolume: function(volume) {
        this._volume = volume;
        if (!this._muted) {
            this.audio.setVolume(volume);
        }
    },

    setMuted: function(muted) {
        this._muted = muted;
        this.audio.setVolume(muted ? 0 : this._volume);
    },

});



// loadMedia puzzle
function loadMedia_WebAudio(url) {
    if (!v3d.Detector.checkWebAudio()) {
        if (!_noWebAudioReported) {
            _noWebAudioReported = true;
            console.warn('v3d.puzzles: Web Audio API not supported');
        }
        return null;
    }

    var elems = _pGlob.mediaElements;
    if (!(url in elems)) {
        elems[url] = new AudioWebAudio().load(url);
    }
    return elems[url];
}



// volume puzzle
function volume(mediaElem, volume) {
    if (!mediaElem)
        return;

    volume = Number(volume);
    if (Number.isNaN(volume)) {
        return;
    }

    mediaElem.setVolume(v3d.Math.clamp(volume, 0.0, 1.0));
}



// everyFrame puzzle
function registerEveryFrame(callback) {
    if (typeof callback == "function")
        appInstance.renderCallbacks.push(callback);
}



// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if (attr === 'style') {
            // NOTE: setting an attribute 'style' instead of a property 'style'
            // fixes IE11 worng behavior
            elem.setAttribute(attr, value);
        } else {
            elem[attr] = value;
        }
    }
}



// getEventProperty puzzle
function getEventProperty(prop, event) {
    if (typeof event != "undefined") {
        switch (prop) {
            case 'target.id':
                return event.target.id;
            case 'target.value':
                return event.target.value;
            case 'touches.length':
                return event.touches ? event.touches.length : 0;
            case 'touches[0].pageX':
                return event.touches[0].pageX;
            case 'touches[0].pageY':
                return event.touches[0].pageY;
            case 'touches[1].pageX':
                return event.touches[1].pageX;
            case 'touches[1].pageY':
                return event.touches[1].pageY;
            default:
                return event[prop];
        }
    }
}



// dictSet puzzle
function dictSet(dict, key, value) {
    if (dict && typeof dict == 'object')
        dict[key] = value;
}



// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;
        elem.addEventListener(eventType, callback, false);
    }
}



// distanceBetweenObjects puzzle
function getDistanceBetweenObjects(objName1, objName2) {
    if (!objName1 || !objName2)
        return;
    var obj1 = getObjectByName(objName1);
    var obj2 = getObjectByName(objName2);
    if (!obj1 || !obj2)
        return;
    return obj1.getWorldPosition(_pGlob.vec3Tmp).distanceTo(obj2.getWorldPosition(_pGlob.vec3Tmp2));
}



function RotationInterface() {
    /**
     * For user manipulations use XYZ extrinsic rotations (which
     * are the same as ZYX intrinsic rotations)
     *     - Blender/Max/Maya use extrinsic rotations in the UI
     *     - XYZ is the default option, but could be set from
     *       some order hint if exported
     */
    this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
    this._actualRotation = new v3d.Euler();
}

Object.assign(RotationInterface, {
    initObject: function(obj) {
        if (obj.userData.v3d.puzzles === undefined) {
            obj.userData.v3d.puzzles = {}
        }
        if (obj.userData.v3d.puzzles.rotationInterface === undefined) {
            obj.userData.v3d.puzzles.rotationInterface = new RotationInterface();
        }

        var rotUI = obj.userData.v3d.puzzles.rotationInterface;
        rotUI.updateFromObject(obj);
        return rotUI;
    }
});

Object.assign(RotationInterface.prototype, {

    updateFromObject: function(obj) {
        var SYNC_ROT_EPS = 1e-8;

        if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
            this._actualRotation.copy(obj.rotation);
            this._updateUserRotFromActualRot();
        }
    },

    getActualRotation: function(euler) {
        return euler.copy(this._actualRotation);
    },

    setUserRotation: function(euler) {
        // don't copy the order, since it's fixed to ZYX for now
        this._userRotation.set(euler.x, euler.y, euler.z);
        this._updateActualRotFromUserRot();
    },

    getUserRotation: function(euler) {
        return euler.copy(this._userRotation);
    },

    _updateUserRotFromActualRot: function() {
        var order = this._userRotation.order;
        this._userRotation.copy(this._actualRotation).reorder(order);
    },

    _updateActualRotFromUserRot: function() {
        var order = this._actualRotation.order;
        this._actualRotation.copy(this._userRotation).reorder(order);
    }

});




// setObjTransform puzzle
function setObjTransform(objNames, mode, x, y, z, offset) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames) return;

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.Math.DEG2RAD);
    }

    var coordSystem = getCoordSystem();

    coordsTransform(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    coordsTransform(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj) continue;

        if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = eulerV3DToBlenderShortest(obj.rotation, _pGlob.eulerTmp);
            coordsTransform(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}



// getObjTransform puzzle
function getObjTransform(objName, mode, coord) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;

    var coordSystem = getCoordSystem();

    var transformVal;

    if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
        transformVal = eulerV3DToBlenderShortest(obj.rotation,
                _pGlob.eulerTmp);
    } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
        // Maya coordinates
        // Use separate rotation interface to fix ambiguous rotations for Maya,
        // might as well do the same for Blender/Max.

        var rotUI = RotationInterface.initObject(obj);
        transformVal = rotUI.getUserRotation(_pGlob.eulerTmp);
    } else {
        transformVal = coordsTransform(obj[mode].clone(), 'Y_UP_RIGHT',
                coordSystem, mode === 'scale');
    }

    if (mode === 'rotation') {
        transformVal.x = v3d.MathUtils.radToDeg(transformVal.x);
        transformVal.y = v3d.MathUtils.radToDeg(transformVal.y);
        transformVal.z = v3d.MathUtils.radToDeg(transformVal.z);
    }

    if (coord == 'xyz') {
        // remove order component for Euler vectors
        return transformVal.toArray().slice(0, 3);
    } else {
        return transformVal[coord];
    }
}



// Copyright (c) 2010-2019 Tween.js authors.
// Easing equations Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/
// Code copied from https://cdnjs.cloudflare.com/ajax/libs/tween.js/17.3.0/Tween.min.js

var _Group=function(){this._tweens={},this._tweensAddedDuringUpdate={}};_Group.prototype={getAll:function(){return Object.keys(this._tweens).map(function(t){return this._tweens[t]}.bind(this))},removeAll:function(){this._tweens={}},add:function(t){this._tweens[t.getId()]=t,this._tweensAddedDuringUpdate[t.getId()]=t},remove:function(t){delete this._tweens[t.getId()],delete this._tweensAddedDuringUpdate[t.getId()]},update:function(t,n){var e=Object.keys(this._tweens);
if(0===e.length)return!1;for(t=void 0!==t?t:TWEEN.now();0<e.length;){this._tweensAddedDuringUpdate={};for(var i=0;i<e.length;i++){var r=this._tweens[e[i]];r&&!1===r.update(t)&&(r._isPlaying=!1,n||delete this._tweens[e[i]])}e=Object.keys(this._tweensAddedDuringUpdate)}return!0}};var TWEEN=new _Group;TWEEN.Group=_Group,TWEEN._nextId=0,TWEEN.nextId=function(){return TWEEN._nextId++},"undefined"==typeof window&&"undefined"!=typeof process&&process.hrtime?TWEEN.now=function(){var t=process.hrtime();
return 1e3*t[0]+t[1]/1e6}:"undefined"!=typeof window&&void 0!==window.performance&&void 0!==window.performance.now?TWEEN.now=window.performance.now.bind(window.performance):void 0!==Date.now?TWEEN.now=Date.now:TWEEN.now=function(){return(new Date).getTime()},TWEEN.Tween=function(t,n){this._object=t,this._valuesStart={},this._valuesEnd={},this._valuesStartRepeat={},this._duration=1e3,this._repeat=0,this._repeatDelayTime=void 0,this._yoyo=!1,this._isPlaying=!1,this._reversed=!1,this._delayTime=0,
this._startTime=null,this._easingFunction=TWEEN.Easing.Linear.None,this._interpolationFunction=TWEEN.Interpolation.Linear,this._chainedTweens=[],this._onStartCallback=null,this._onStartCallbackFired=!1,this._onUpdateCallback=null,this._onCompleteCallback=null,this._onStopCallback=null,this._group=n||TWEEN,this._id=TWEEN.nextId()},TWEEN.Tween.prototype={getId:function(){return this._id},isPlaying:function(){return this._isPlaying},to:function(t,n){return this._valuesEnd=t,void 0!==n&&(this._duration=n),this},start:function(t){for(var n in this._group.add(this),this._isPlaying=!0,this._onStartCallbackFired=!1,this._startTime=void 0!==t?"string"==typeof t?TWEEN.now()+parseFloat(t):t:TWEEN.now(),this._startTime+=this._delayTime,this._valuesEnd){if(this._valuesEnd[n]instanceof Array){if(0===this._valuesEnd[n].length)continue;
this._valuesEnd[n]=[this._object[n]].concat(this._valuesEnd[n])}void 0!==this._object[n]&&(this._valuesStart[n]=this._object[n],this._valuesStart[n]instanceof Array==!1&&(this._valuesStart[n]*=1),this._valuesStartRepeat[n]=this._valuesStart[n]||0)}return this},stop:function(){return this._isPlaying&&(this._group.remove(this),this._isPlaying=!1,null!==this._onStopCallback&&this._onStopCallback(this._object),this.stopChainedTweens()),this},end:function(){return this.update(this._startTime+this._duration),this},stopChainedTweens:function(){for(var t=0,n=this._chainedTweens.length;t<n;
t++)this._chainedTweens[t].stop()},group:function(t){return this._group=t,this},delay:function(t){return this._delayTime=t,this},repeat:function(t){return this._repeat=t,this},repeatDelay:function(t){return this._repeatDelayTime=t,this},yoyo:function(t){return this._yoyo=t,this},easing:function(t){return this._easingFunction=t,this},interpolation:function(t){return this._interpolationFunction=t,this},chain:function(){return this._chainedTweens=arguments,this},onStart:function(t){return this._onStartCallback=t,this},onUpdate:function(t){return this._onUpdateCallback=t,this},onComplete:function(t){return this._onCompleteCallback=t,this},onStop:function(t){return this._onStopCallback=t,this},update:function(t){var n,e,i;if(t<this._startTime)return!0;
for(n in!1===this._onStartCallbackFired&&(null!==this._onStartCallback&&this._onStartCallback(this._object),this._onStartCallbackFired=!0),e=(t-this._startTime)/this._duration,e=0===this._duration||1<e?1:e,i=this._easingFunction(e),this._valuesEnd)if(void 0!==this._valuesStart[n]){var r=this._valuesStart[n]||0,a=this._valuesEnd[n];a instanceof Array?this._object[n]=this._interpolationFunction(a,i):("string"==typeof a&&(a="+"===a.charAt(0)||"-"===a.charAt(0)?r+parseFloat(a):parseFloat(a)),"number"==typeof a&&(this._object[n]=r+(a-r)*i))}if(null!==this._onUpdateCallback&&this._onUpdateCallback(this._object),1!==e)return!0;
if(0<this._repeat){for(n in isFinite(this._repeat)&&this._repeat--,this._valuesStartRepeat){if("string"==typeof this._valuesEnd[n]&&(this._valuesStartRepeat[n]=this._valuesStartRepeat[n]+parseFloat(this._valuesEnd[n])),this._yoyo){var s=this._valuesStartRepeat[n];this._valuesStartRepeat[n]=this._valuesEnd[n],this._valuesEnd[n]=s}this._valuesStart[n]=this._valuesStartRepeat[n]}return this._yoyo&&(this._reversed=!this._reversed),void 0!==this._repeatDelayTime?this._startTime=t+this._repeatDelayTime:this._startTime=t+this._delayTime,!0}null!==this._onCompleteCallback&&this._onCompleteCallback(this._object);for(var o=0,u=this._chainedTweens.length;o<u;o++)this._chainedTweens[o].start(this._startTime+this._duration);
return!1}},TWEEN.Easing={Linear:{None:function(t){return t}},Quadratic:{In:function(t){return t*t},Out:function(t){return t*(2-t)},InOut:function(t){return(t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)}},Cubic:{In:function(t){return t*t*t},Out:function(t){return--t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t:.5*((t-=2)*t*t+2)}},Quartic:{In:function(t){return t*t*t*t},Out:function(t){return 1- --t*t*t*t},InOut:function(t){return(t*=2)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)}},Quintic:{In:function(t){return t*t*t*t*t},Out:function(t){return--t*t*t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)}},Sinusoidal:{In:function(t){return 1-Math.cos(t*Math.PI/2)},Out:function(t){return Math.sin(t*Math.PI/2)},InOut:function(t){return.5*(1-Math.cos(Math.PI*t))}},Exponential:{In:function(t){return 0===t?0:Math.pow(1024,t-1)},Out:function(t){return 1===t?1:1-Math.pow(2,-10*t)},
InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?.5*Math.pow(1024,t-1):.5*(2-Math.pow(2,-10*(t-1)))}},Circular:{In:function(t){return 1-Math.sqrt(1-t*t)},Out:function(t){return Math.sqrt(1- --t*t)},InOut:function(t){return(t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)}},Elastic:{In:function(t){return 0===t?0:1===t?1:-Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)},Out:function(t){return 0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin(5*(t-.1)*Math.PI)+1},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?-.5*Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI):.5*Math.pow(2,-10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)+1}},Back:{In:function(t){return t*t*(2.70158*t-1.70158)},Out:function(t){return--t*t*(2.70158*t+1.70158)+1},InOut:function(t){var n=2.5949095;
return(t*=2)<1?t*t*((n+1)*t-n)*.5:.5*((t-=2)*t*((n+1)*t+n)+2)}},Bounce:{In:function(t){return 1-TWEEN.Easing.Bounce.Out(1-t)},Out:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},InOut:function(t){return t<.5?.5*TWEEN.Easing.Bounce.In(2*t):.5*TWEEN.Easing.Bounce.Out(2*t-1)+.5}}},TWEEN.Interpolation={Linear:function(t,n){var e=t.length-1,i=e*n,r=Math.floor(i),a=TWEEN.Interpolation.Utils.Linear;return n<0?a(t[0],t[1],i):1<n?a(t[e],t[e-1],e-i):a(t[r],t[e<r+1?e:r+1],i-r)},Bezier:function(t,n){for(var e=0,i=t.length-1,r=Math.pow,a=TWEEN.Interpolation.Utils.Bernstein,s=0;s<=i;s++)e+=r(1-n,i-s)*r(n,s)*t[s]*a(i,s);return e},CatmullRom:function(t,n){var e=t.length-1,i=e*n,r=Math.floor(i),a=TWEEN.Interpolation.Utils.CatmullRom;
return t[0]===t[e]?(n<0&&(r=Math.floor(i=e*(1+n))),a(t[(r-1+e)%e],t[r],t[(r+1)%e],t[(r+2)%e],i-r)):n<0?t[0]-(a(t[0],t[0],t[1],t[1],-i)-t[0]):1<n?t[e]-(a(t[e],t[e],t[e-1],t[e-1],i-e)-t[e]):a(t[r?r-1:0],t[r],t[e<r+1?e:r+1],t[e<r+2?e:r+2],i-r)},Utils:{Linear:function(t,n,e){return(n-t)*e+t},Bernstein:function(t,n){var e=TWEEN.Interpolation.Utils.Factorial;return e(t)/e(n)/e(t-n)},Factorial:function(){var i=[1];return function(t){var n=1;if(i[t])return i[t];for(var e=t;1<e;e--)n*=e;return i[t]=n}}(),CatmullRom:function(t,n,e,i,r){var a=.5*(e-t),s=.5*(i-n),o=r*r;return(2*n-2*e+a+s)*(r*o)+(-3*n+3*e-2*a-s)*o+a*r+n}}},function(t){"function"==typeof define&&define.amd?define([],function(){return TWEEN}):"undefined"!=typeof module&&"object"==typeof exports?module.exports=TWEEN:void 0!==t&&(t.TWEEN=TWEEN)}(this);



// animateParam puzzle
appInstance.renderCallbacks.push(function() { TWEEN.update(); });



// animateParam puzzle
function animateParam(from, to, duration, easing, easing2, repeat, yoyo, on_update, when_finished) {

    var mode = easing == "Linear" ?
        TWEEN.Easing.Linear.None : TWEEN.Easing[easing][easing2];

    var tweenObject = (typeof from != "number");

    if (!tweenObject) { // number
        from = [from];
        to = [to];
    }

    var tween = new TWEEN.Tween(from)
                    .to(to, duration * 1000)
                    .easing(mode)
                    .repeat(repeat)
                    .yoyo(yoyo)
                    .onUpdate(function (object) {
                        if (tweenObject)
                            _pGlob.animateParamUpdate = object;
                        else // number
                            _pGlob.animateParamUpdate = object[0];
                        on_update();
                    })
                    .onComplete(function (object) {
                        when_finished();
                    })
                    .start();
}



// featureAvailable puzzle
function featureAvailable(feature) {

    var userAgent = window.navigator.userAgent;
    var platform = window.navigator.platform;

    switch (feature) {
    case 'LINUX':
        return /Linux/.test(platform);
    case 'WINDOWS':
        return ['Win32', 'Win64', 'Windows', 'WinCE'].indexOf(platform) !== -1;
    case 'MACOS':
        return (['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'].indexOf(platform) !== -1 && !v3d.Detector.checkIOS());
    case 'IOS':
        return v3d.Detector.checkIOS();
    case 'ANDROID':
        return /Android/i.test(userAgent);
    case 'MOBILE':
        return (/Android|webOS|BlackBerry/i.test(userAgent) || v3d.Detector.checkIOS());

    case 'CHROME':
        // Chromium based
        return (!!window.chrome && !/Edge/.test(navigator.userAgent));
    case 'FIREFOX':
        return /Firefox/.test(navigator.userAgent);
    case 'IE':
        return /Trident/.test(navigator.userAgent);
    case 'EDGE':
        return /Edge/.test(navigator.userAgent);
    case 'SAFARI':
        return (/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent));

    case 'TOUCH':
        return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
    case 'RETINA':
        return window.devicePixelRatio >= 2;
    case 'HDR':
        return appInstance.useHDR;
    case 'WEBAUDIO':
        return v3d.Detector.checkWebAudio();
    case 'WEBGL2':
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl2')
        return !!gl;
    case 'WOOCOMMERCE':
        var woo_fun = window.parent.v3d_woo_get_product_info || window.parent.parent.v3d_woo_get_product_info;
        return !!woo_fun;
    default:
        return false;
    }

}



// show and hide puzzles
function changeVis(objNames, bool) {
    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
    }
}



// playSound puzzle
function playSound(mediaElem, loop) {
    if (!mediaElem)
        return;
    mediaElem.setLoop(loop);
    mediaElem.play();
}



// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}



// whenClicked puzzle
function registerOnClick(objNames, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {
    objNames = retrieveObjectNames(objNames) || [];

    var objNamesFiltered = objNames.filter(function(name) {
        return name;
    });

    // for AR/VR
    _pGlob.objClickInfo.push({
        objNames: objNamesFiltered,
        callbacks: [cbDo, cbIfMissedDo]
    });

    initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);

            if (objectsIncludeObj(objNamesFiltered, objName)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }

        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}



// onSimulationTick puzzle
function onSimulationTick(tickType, tickCallback) {

    if (!_pPhysics.tickCallbacks.length) {
        var preTickCb = function(worldPtr, timeStep) {
            _pPhysics.tickCallbacks.forEach(function(pair) {
                if (pair[0] == 'BEFORE')
                    pair[1]();
            });
        }

        var tickCb = function(worldPtr, timeStep) {
            _pPhysics.tickCallbacks.forEach(function(pair) {
                if (pair[0] == 'AFTER')
                    pair[1]();
            });
        }

        _pPhysics.world.setInternalTickCallback(Ammo.addFunction(preTickCb, 'vif'), 0, true);
        _pPhysics.world.setInternalTickCallback(Ammo.addFunction(tickCb, 'vif'), 0, false);
    }

    _pPhysics.tickCallbacks.push([tickType, tickCallback]);

}



// getHTMLElemAttribute puzzle
function getHTMLElemAttribute(attr, id, isParent) {
    var elem = getElement(id, isParent);
    return elem ? elem[attr]: '';
}



// snapToObject puzzle
function snapToObject(objName, targetObjName) {
    if (!objName || !targetObjName)
        return;
    var obj = getObjectByName(objName);
    var targetObj = getObjectByName(targetObjName);
    if (!obj || !targetObj)
        return;
    obj.copyTransform(targetObj);
    obj.updateMatrixWorld(true);
}


// Describe this function...
function interface_recalc() {
  screen_ratio = getHTMLElemAttribute('clientHeight', ['CONTAINER'], false) / getHTMLElemAttribute('clientWidth', ['CONTAINER'], false);
  setObjTransform('camera_bottom', 'position', '', '', map_range(0.5, 0.1, -0.2, 0.05, screen_ratio), false);
  if (race_started == true) {
    snapToObject('minutes_counter_1', 'time_place_1');
    snapToObject('minutes_counter_2', 'time_place_1');
    snapToObject('seconds_couner_1', 'time_place_1');
    snapToObject('seconds_couner_2', 'time_place_1');
    snapToObject('colon', 'time_place_1');
  }
}

// Describe this function...
function rotate_your_device_message() {
  if (getHTMLElemAttribute('clientHeight', ['CONTAINER'], false) / getHTMLElemAttribute('clientWidth', ['CONTAINER'], false) >= 1) {
    changeVis('rotate_your_device', true);
  } else {
    changeVis('rotate_your_device', false);
  }
}


/**
 * Find physics body associated with the given object and remove it.
 */
_pPhysics.findRemovePhysicsBody = function(obj) {

    for (var i = 0; i < _pPhysics.syncList.length; i++) {
        var syncData = _pPhysics.syncList[i];

        if (syncData.obj == obj) {

            if (syncData.type == 'SOFT_BODY')
                _pPhysics.world.removeSoftBody(syncData.body);
            else
                _pPhysics.world.removeRigidBody(syncData.body);

            Ammo.destroy(syncData.body);
            _pPhysics.syncList.splice(i, 1);
            i--;
        }
    }
}

/**
 * Find physics constraint associated with the given objects and remove it.
 */
_pPhysics.findRemovePhysicsConstraint = function(obj1, obj2) {

    for (var i = 0; i < _pPhysics.consList.length; i++) {

        var consData = _pPhysics.consList[i];

        if (consData.obj1 == obj1 && consData.obj2 == obj2) {

            _pPhysics.world.removeConstraint(consData.cons);
            Ammo.destroy(consData.cons);
            _pPhysics.consList.splice(i, 1);
            i--;

        }

    }

}

/**
 * Cleanup forces and velocities
 */
_pPhysics.resetBody = function(body) {
    body.clearForces();

    var zeroVec = new Ammo.btVector3(0, 0, 0);

    body.setLinearVelocity(zeroVec);
    body.setAngularVelocity(zeroVec);
}

_pPhysics.setObjToBodyTransform = function(obj, body) {
    var pos = obj.getWorldPosition(_pGlob.vec3Tmp);
    var quat = obj.getWorldQuaternion(_pGlob.quatTmp);

    _pPhysics.transTmp.setIdentity();
    _pPhysics.transTmp.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
    _pPhysics.transTmp.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));

    body.setWorldTransform(_pPhysics.transTmp);
    body.getMotionState().setWorldTransform(_pPhysics.transTmp);
}



// createPhysicsBody puzzle
function createPhysicsBody(type, objNames, shape, mass) {

    if (!window.Ammo)
        return;

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj)
            return;

        _pPhysics.findRemovePhysicsBody(obj);

        switch (shape) {
        case 'BOX':
        case 'CAPSULE':
        case 'CONE':
        case 'CYLINDER':

            var box = new v3d.Box3();

            obj.resolveMultiMaterial().forEach(function(objR) {
                if (objR.geometry) {
                    if (objR.geometry.boundingBox == null)
                        objR.geometry.computeBoundingBox();

                    box.union(objR.geometry.boundingBox);
                }
            });

            var size = box.getSize(new v3d.Vector3());

            // do not allow empty-sized shapes
            size.x = size.x || 0.5;
            size.y = size.y || 0.5;
            size.z = size.z || 0.5;

            if (shape == 'BOX') {
                var geometry = new Ammo.btBoxShape(new Ammo.btVector3(
                        size.x * 0.5, size.y * 0.5, size.z * 0.5));
            } else if (shape == 'CAPSULE') {
                var radius = Math.max(size.x, size.z) * 0.5;
                var height = size.y - 2 * radius;
                var geometry = new Ammo.btCapsuleShape(radius, height);
            } else if (shape == 'CONE') {
                var radius = Math.max(size.x, size.z) * 0.5;
                var height = size.y;
                var geometry = new Ammo.btConeShape(radius, height);
            } else {
                var geometry = new Ammo.btCylinderShape(new Ammo.btVector3(
                        size.x * 0.5, size.y * 0.5, size.z * 0.5));
            }

            break;
        case 'SPHERE':

            var sphere = new v3d.Sphere();

            obj.resolveMultiMaterial().forEach(function(objR) {

                if (objR.geometry) {
                    if (objR.geometry.boundingSphere === null)
                        objR.geometry.computeBoundingSphere();

                    sphere.union(objR.geometry.boundingSphere);
                }
            });

            var geometry = new Ammo.btSphereShape(sphere.radius || 0.5);

            break;
        case 'MESH':

            var objsR = obj.resolveMultiMaterial();

            if (!objsR[0].geometry || !objsR[0].isMesh) {
                console.error('create rigid body: incorrect mesh object');
                var geometry = new Ammo.btEmptyShape();
                break;
            }

            // allow complex triangle shapes for KINEMATIC objects
            if (type == 'DYNAMIC' || type == 'GHOST') {

                var geometry = new Ammo.btConvexHullShape();

                objsR.forEach(function(objR) {
                    var positions = objR.geometry.attributes.position.array;

                    for (var i = 0; i < positions.length; i+=3) {
                        var x = positions[i];
                        var y = positions[i+1];
                        var z = positions[i+2];

                        var v = new Ammo.btVector3(x, y, z);

                        geometry.addPoint(v);

                        Ammo.destroy(v);
                    }
                });

            } else {

                var triIdxVertArray = new Ammo.btTriangleMesh();

                objsR.forEach(function(objR) {
                    var positions = objR.geometry.attributes.position.array;
                    var indices = objR.geometry.index.array;

                    for (var i = 0; i < indices.length; i+=3) {

                        var i1 = indices[i];
                        var i2 = indices[i+1];
                        var i3 = indices[i+2];

                        var v1 = new Ammo.btVector3(positions[3*i1], positions[3*i1+1], positions[3*i1+2]);
                        var v2 = new Ammo.btVector3(positions[3*i2], positions[3*i2+1], positions[3*i2+2]);
                        var v3 = new Ammo.btVector3(positions[3*i3], positions[3*i3+1], positions[3*i3+2]);

                        triIdxVertArray.addTriangle(v1, v2, v3, false);

                        Ammo.destroy(v1);
                        Ammo.destroy(v2);
                        Ammo.destroy(v3);
                    }
                });

                var geometry = new Ammo.btBvhTriangleMeshShape(triIdxVertArray, true);

            }

            break;
        case 'EMPTY':
            var geometry = new Ammo.btEmptyShape();
            break;
        }

        var pos = obj.getWorldPosition(_pGlob.vec3Tmp);
        var quat = obj.getWorldQuaternion(_pGlob.quatTmp);

        var transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
        transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
        var motionState = new Ammo.btDefaultMotionState(transform);

        if (type == 'STATIC' || type == 'KINEMATIC' || type == 'GHOST')
            var bodyMass = 0;
        else
            var bodyMass = mass;

        var localInertia = new Ammo.btVector3(0, 0, 0);
        geometry.calculateLocalInertia(bodyMass, localInertia);

        var rbInfo = new Ammo.btRigidBodyConstructionInfo(bodyMass, motionState, geometry, localInertia);
        var body = new Ammo.btRigidBody(rbInfo);

        // CF_STATIC_OBJECT is set automatically

        if (type == 'KINEMATIC' || type == 'GHOST') {
            body.setCollisionFlags(body.getCollisionFlags() | CF_KINEMATIC_OBJECT);
            body.setActivationState(DISABLE_DEACTIVATION);
        }

        if (type == 'GHOST') {

            body.setCollisionFlags(body.getCollisionFlags() | CF_NO_CONTACT_RESPONSE);
            _pPhysics.world.addRigidBody(body, SensorTrigger, AllFilter);

        } else {

            _pPhysics.world.addRigidBody(body);

        }


        //body.setDamping(0.1, 0.1);

        _pPhysics.syncList.push({
            obj: obj,
            body: body,
            type: type,
            simulated: true,
            mass: mass
        });

        // external physics interface
        if (v3d.PL) {
            v3d.PL.physics.bodies[objName] = body;
        }
    });


}



// detectCollision puzzle
function detectCollision(objNamesA, objNamesB, collideCb, noCollideCb) {

    objNamesA = retrieveObjectNames(objNamesA);
    if (!objNamesA)
        return;

    objNamesB = retrieveObjectNames(objNamesB);
    if (!objNamesB)
        return;

    var objA = getObjectByName(objNamesA[0]);
    var execInstanceID = v3d.MathUtils.generateUUID();

    for (var i = 0; i < objNamesB.length; i++) {
        var objB = getObjectByName(objNamesB[i]);

        var bodyA = null;
        var bodyB = null;

        for (var j = 0; j < _pPhysics.syncList.length; j++) {
            var syncData = _pPhysics.syncList[j];

            if (syncData.obj == objA)
                bodyA = syncData.body;

            if (syncData.obj == objB)
                bodyB = syncData.body;
        }

        if (objA && objB && bodyA && bodyB) {
            _pPhysics.collisionData.push({
                objA: objA,
                objB: objB,
                bodyA: bodyA,
                bodyB: bodyB,
                collideCb: collideCb,
                noCollideCb: noCollideCb,
                collideFlag: true,
                execInstanceID: execInstanceID
            });
        }
    }

}



/**
 * mesh or multi-material object
 */
function isMeshObj(obj) {
    if (obj.isMesh)
        return true;

    for (var i = 0; i < obj.children.length; i++) {
        var child = obj.children[i];
        if (child.isMesh && child.isMaterialGeneratedMesh)
            return true;
    }

    return false;
}




function getObjectsFromCollect(obj, type, out) {
    if (!notIgnoredObj(obj))
        return;

    switch (type) {
    case 'ALL':
        if (out.indexOf(obj.name) < 0)
            out.push(obj.name);
        break;
    case 'ANNOTATION':
        if (obj.isAnnotation && out.indexOf(obj.name) < 0)
            out.push(obj.name);
        break;
    case 'BONE':
        if (obj.isBone && out.indexOf(obj.name) < 0)
            out.push(obj.name);
        break;
    case 'CAMERA':
        if (obj.isCamera && out.indexOf(obj.name) < 0)
            out.push(obj.name);
        break;
    case 'EMPTY':
        if (!obj.isAnnotationControl && !obj.isBone && !obj.isCamera && !obj.isGroup &&
                !obj.isLine && !obj.isLOD && !obj.isLight && !isMeshObj(obj) && !obj.isPoints &&
                !obj.isScene && !obj.isSprite && out.indexOf(obj.name) < 0)
            out.push(obj.name);
        break;
    case 'LIGHT':
        if (obj.isLight && out.indexOf(obj.name) < 0)
            out.push(obj.name);
        break;
    case 'MESH':
        if (isMeshObj(obj) && out.indexOf(obj.name) < 0)
            out.push(obj.name);
        break;
    default:
        console.error('getObjectsFrom: Unknown object type: ' + type);
        break;
    }

    for (var i = 0; i < obj.children.length; i++) {
        var child = obj.children[i];
        getObjectsFromCollect(child, type, out);
    }
}

// getObjectsFrom puzzle
function getObjectsFrom(objNames, type) {

    var out = [];

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;

        var obj = getObjectByName(objName);
        if (!obj)
            continue;

        getObjectsFromCollect(obj, type, out);
    }

    return out;
}



function setMorphFactor(objName, targetName, factor) {

    if (objName && targetName) {
        var obj = getObjectByName(objName);
        if (obj) {
            obj.resolveMultiMaterial().forEach(function(objR) {
                if (objR.morphTargetDictionary && targetName in objR.morphTargetDictionary) {
                    var idx = objR.morphTargetDictionary[targetName];
                    objR.morphTargetInfluences[idx] = Number(factor);
                }
            });
        }
    }

}


// Describe this function...
function car_repair() {
  summ_damage = 0;
  front_damaged = 0;
  front_right_damaged = 0;
  front_left_damaged = 0;
  rear_damaged = 0;
  rear_left_damaged = 0;
  rear_right_damaged = 0;
  engine_force_recalc();
  setMorphFactor('car_body', 'front_damage', 0);
  setMorphFactor('car_body', 'front_left_damage', 0);
  setMorphFactor('car_body', 'front_right_damage', 0);
  setMorphFactor('car_body', 'rear_damage', 0);
  setMorphFactor('car_body', 'rear_left_damage', 0);
  setMorphFactor('car_body', 'rear_right_damage', 0);
  setMorphFactor('front_left', 'damage', 0);
  setMorphFactor('front_right', 'damage', 0);
  setMorphFactor('rear_left', 'damage', 0);
  setMorphFactor('rear_right', 'damage', 0);
  damage_map_update();
  playSound(loadMedia_WebAudio('./sounds/car_fixing.mp3'), false);
}


/**
 * Retreive standard accessible textures for MeshNodeMaterial or MeshStandardMaterial.
 * If "collectSameNameMats" is true then all materials in the scene with the given name will
 * be used for collecting textures, otherwise will be used only the first found material (default behavior).
 */
function matGetEditableTextures(matName, collectSameNameMats) {

    var mats = [];
    if (collectSameNameMats) {
        mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
    } else {
        var firstMat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
        if (firstMat !== null) {
            mats = [firstMat];
        }
    }

    var textures = mats.reduce(function(texArray, mat) {
        var matTextures = [];
        switch (mat.type) {
            case 'MeshNodeMaterial':
                matTextures = Object.values(mat.nodeTextures);
                break;

            case 'MeshStandardMaterial':
                matTextures = [
                    mat.map, mat.lightMap, mat.aoMap, mat.emissiveMap,
                    mat.bumpMap, mat.normalMap, mat.displacementMap,
                    mat.roughnessMap, mat.metalnessMap, mat.alphaMap, mat.envMap
                ]
                break;

            default:
                console.error('matGetEditableTextures: Unknown material type ' + mat.type);
                break;
        }

        Array.prototype.push.apply(texArray, matTextures);
        return texArray;
    }, []);

    return textures.filter(function(elem) {
        // check Texture type exactly
        return elem && (elem.constructor == v3d.Texture
                || elem.constructor == v3d.DataTexture
                || elem.constructor == v3d.VideoTexture);
    });
}



/**
 * Replace accessible textures for MeshNodeMaterial or MeshStandardMaterial
 */
function matReplaceEditableTexture(mat, oldTex, newTex) {

    switch (mat.type) {
        case 'MeshNodeMaterial':
            for (var name in mat.nodeTextures) {
                if (mat.nodeTextures[name] == oldTex) {
                    mat.nodeTextures[name] = newTex;
                }
            }

            break;

        case 'MeshStandardMaterial':

            var texNames = ['map', 'lightMap', 'aoMap', 'emissiveMap',
                            'bumpMap', 'normalMap', 'displacementMap', 'roughnessMap',
                            'metalnessMap', 'alphaMap', 'envMap'];

            texNames.forEach(function(name) {
                if (mat[name] == oldTex) {
                    mat[name] = newTex;
                }
            });

            break;

        default:
            console.error('matReplaceEditableTexture: Unsupported material type ' + mat.type);
            break;
    }

}



// replaceTexture puzzle
function replaceTexture(matName, texName, texUrlOrElem, doCb) {

    var textures = matGetEditableTextures(matName, true).filter(function(elem) {
        return elem.name == texName;
    });

    if (!textures.length)
        return;

    if (texUrlOrElem instanceof Promise) {

        texUrlOrElem.then(function(response) {
           processImageUrl(response);
        }, function(error) {});

    } else if (typeof texUrlOrElem == 'string') {

        processImageUrl(texUrlOrElem);

    /**
     * NOTE: not checking for the MediaHTML5 constructor, because otherwise this
     * puzzle would always provide the code that's not needed most of the time
     */
    } else if (texUrlOrElem instanceof Object && texUrlOrElem.source
            instanceof HTMLVideoElement) {

        processVideo(texUrlOrElem.source);

    } else if (texUrlOrElem instanceof HTMLCanvasElement) {

        processCanvas(texUrlOrElem);

    } else {

        return;

    }

    function processImageUrl(url) {

        var isHDR = (url.search(/\.hdr$/) > 0);

        if (!isHDR) {
            var loader = new v3d.ImageLoader();
            loader.setCrossOrigin('Anonymous');
        } else {
            var loader = new v3d.FileLoader();
            loader.setResponseType('arraybuffer');
        }

        loader.load(url, function(image) {
            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
            var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;

            textures.forEach(function(elem) {

                if (!isHDR) {
                    elem.image = image;
                } else {
                    // parse loaded HDR buffer
                    var rgbeLoader = new v3d.RGBELoader();
                    var texData = rgbeLoader.parse(image);

                    // NOTE: reset params since the texture may be converted to float
                    elem.type = v3d.UnsignedByteType;
                    elem.encoding = v3d.RGBEEncoding;

                    elem.image = {
                        data: texData.data,
                        width: texData.width,
                        height: texData.height
                    }

                    elem.magFilter = v3d.LinearFilter;
                    elem.minFilter = v3d.LinearFilter;
                    elem.generateMipmaps = false;
                    elem.isDataTexture = true;

                }

                elem.format = isJPEG ? v3d.RGBFormat : v3d.RGBAFormat;
                elem.needsUpdate = true;

                // update world material if it is using this texture
                var wMat = appInstance.worldMaterial;
                if (wMat)
                    for (var texName in wMat.nodeTextures)
                        if (wMat.nodeTextures[texName] == elem)
                            appInstance.updateEnvironment(wMat);

            });

            // exec once
            doCb();

        });
    }

    function processVideo(elem) {
        var videoTex = new v3d.VideoTexture(elem);
        videoTex.flipY = false;
        videoTex.name = texName;

        var videoAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            textures.forEach(function(tex) {
                matReplaceEditableTexture(mat, tex, videoTex);
            });

            mat.needsUpdate = true;
            videoAssigned = true;
        });

        if (videoAssigned)
            doCb();

    }

    function processCanvas(elem) {
        var canvasTex = new v3d.CanvasTexture(elem);
        canvasTex.flipY = false;
        canvasTex.name = texName;

        var canvasAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            textures.forEach(function(tex) {
                matReplaceEditableTexture(mat, tex, canvasTex);
            });

            mat.needsUpdate = true;
            canvasAssigned = true;
        });

        if (canvasAssigned) {

            if (v3d.PL) {
                v3d.PL.canvasTextures = v3d.PL.canvasTextures || {};
                v3d.PL.canvasTextures[canvasTex.image.id] = canvasTex;
            }

            doCb();
        }

    }
}



// makeParent puzzle
function makeParent(objName, targetObjName) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;
    if (targetObjName && targetObjName !== LIST_NONE) {
        var targetObj = getObjectByName(targetObjName);
        if (!targetObj)
            return;
    } else {
        obj.traverseAncestors(function(ancObj) {
            if (ancObj.type == "Scene")
                targetObj = ancObj;
        });
    }
    var matOffset = new v3d.Matrix4();
    matOffset.getInverse(targetObj.matrixWorld);
    matOffset.multiply(obj.matrixWorld);
    matOffset.decompose(obj.position, obj.quaternion, obj.scale);
    targetObj.add(obj);

    obj.updateMatrixWorld(true);
}



// physicsBodyApplyParam puzzle
function physicsBodyApplyParam(type, objNames, param) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    if (Array.isArray(param)) {
        var vec = _pGlob.vec3Tmp.fromArray(param);
        var noSignChange = (type == 'LINEAR_FACTOR' || type == 'ANGULAR_FACTOR');
        coordsTransform(vec, getCoordSystem(), 'Y_UP_RIGHT', noSignChange);
    }

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj)
            return;

        var btVec;

        for (var i = 0; i < _pPhysics.syncList.length; i++) {
            var syncData = _pPhysics.syncList[i];

            if (syncData.obj == obj) {

                var body = syncData.body;

                if (Array.isArray(param))
                    btVec = new Ammo.btVector3(vec.x, vec.y, vec.z);
                else if (type == 'GRAVITY')
                    btVec = new Ammo.btVector3(0, 0, 0);

                switch (type) {
                case 'ANGULAR_DAMPING':
                    body.setDamping(body.getLinearDamping(), param);
                    break;
                case 'ANGULAR_FACTOR':
                    body.setAngularFactor(btVec);
                    break;
                case 'ANGULAR_VELOCITY':
                    body.setAngularVelocity(btVec);
                    break;
                case 'FORCE':
                    body.applyCentralForce(btVec);
                    break;
                case 'FRICTION':
                    if (syncData.type != 'SOFT_BODY') {
                        body.setFriction(param);
                    } else {
                        var sbConfig = body.get_m_cfg();
                        sbConfig.set_kDF(param);
                    }
                    break;
                case 'GRAVITY':
                    if (Array.isArray(param)) {
                        body.setGravity(btVec);
                    } else {
                        btVec.setY(-param);
                        body.setGravity(btVec);
                    }
                    break;
                case 'IMPULSE':
                    body.applyCentralImpulse(btVec);
                    break;
                case 'LINEAR_DAMPING':
                    if (syncData.type != 'SOFT_BODY') {
                        body.setDamping(param, body.getAngularDamping());
                    } else {
                        var sbConfig = body.get_m_cfg();
                        sbConfig.set_kDP(param);
                    }
                    break;
                case 'LINEAR_FACTOR':
                    body.setLinearFactor(btVec);
                    break;
                case 'LINEAR_VELOCITY':
                    body.setLinearVelocity(btVec);
                    break;
                case 'POSITION':
                    _pPhysics.transTmp.setIdentity();
                    _pPhysics.transTmp.setOrigin(btVec);

                    var quat = obj.quaternion;
                    _pPhysics.transTmp.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));

                    body.setWorldTransform(_pPhysics.transTmp);
                    break;
                case 'RESTITUTION':
                    body.setRestitution(param);
                    break;
                case 'STIFFNESS':
                    if (syncData.type == 'SOFT_BODY') {
                        body.get_m_materials().at(0).set_m_kLST(param);
                        body.get_m_materials().at(0).set_m_kAST(param);
                    } else {
                        console.error('apply body param: Stiffness param is not applicable for rigid bodies');
                    }
                    break;
                case 'TORQUE':
                    body.applyTorque(btVec);
                    break;
                case 'TORQUE_IMPULSE':
                    body.applyTorqueImpulse(btVec);
                    break;
                }

                if (btVec)
                    Ammo.destroy(btVec);
            }
        }

    });


}



// setBodyState puzzle
function setBodyState(newState, objNames) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj)
            return;

        for (var i = 0; i < _pPhysics.syncList.length; i++) {
            var syncData = _pPhysics.syncList[i];

            if (syncData.obj == obj) {

                var body = syncData.body;

                switch (newState) {
                case 'ACTIVATE':
                    body.activate();
                    break;
                case 'SLEEP':
                    body.setActivationState(ISLAND_SLEEPING);
                    break;
                case 'ENABLE_SIMULATION':
                    body.setCollisionFlags(body.getCollisionFlags() & ~CF_NO_CONTACT_RESPONSE);
                    body.forceActivationState(ACTIVE_TAG);
                    body.activate();

                    _pPhysics.setObjToBodyTransform(syncData.obj, body);

                    syncData.simulated = true;
                    break;
                case 'DISABLE_SIMULATION':
                    body.setCollisionFlags(body.getCollisionFlags() | CF_NO_CONTACT_RESPONSE);
                    body.forceActivationState(DISABLE_SIMULATION);
                    syncData.simulated = false;
                    break;
                case 'RESET':
                    _pPhysics.resetBody(body);
                    break;
                case 'ENABLE_CONTACT_RESP':
                    body.setCollisionFlags(body.getCollisionFlags() & ~CF_NO_CONTACT_RESPONSE);
                    break;
                case 'DISABLE_CONTACT_RESP':
                    body.setCollisionFlags(body.getCollisionFlags() | CF_NO_CONTACT_RESPONSE);
                    break;
                case 'MAKE_DYNAMIC':
                    body.setCollisionFlags(body.getCollisionFlags() & ~CF_KINEMATIC_OBJECT);
                    body.setCollisionFlags(body.getCollisionFlags() & ~CF_STATIC_OBJECT);

                    var localInertia = new Ammo.btVector3(0, 0, 0);
                    body.getCollisionShape().calculateLocalInertia(syncData.mass, localInertia);
                    body.setMassProps(syncData.mass, localInertia);

                    // enable deactivation
                    body.forceActivationState(ACTIVE_TAG);
                    body.activate();

                    break;
                case 'MAKE_KINEMATIC':
                    body.setCollisionFlags(body.getCollisionFlags() | CF_KINEMATIC_OBJECT);
                    body.setActivationState(DISABLE_DEACTIVATION);
                    break;
                case 'MAKE_STATIC':
                    body.setCollisionFlags(body.getCollisionFlags() | CF_STATIC_OBJECT);
                    break;
                case 'ENABLE_DEACTIVATION':
                    body.forceActivationState(ACTIVE_TAG);
                    break;
                case 'DISABLE_DEACTIVATION':
                    body.setActivationState(DISABLE_DEACTIVATION);
                    break;
                }

                // add / remove

            }

        }

    });
}



// removeObject puzzles
function removeObject(objNames) {
    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj || !obj.parent)
            continue;

        obj.parent.remove(obj);

        // clean object cache
        _pGlob.objCache = {};
    }
}



// isSoundPlaying puzzle
function isSoundPlaying(mediaElem) {
    if (!mediaElem)
        return false;
    return mediaElem.isPlaying();
}



// physicsBodyGetParam puzzle
function physicsBodyGetParam(type, objName) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;

    var btVec = null;
    var param = 0;

    for (var i = 0; i < _pPhysics.syncList.length; i++) {
        var syncData = _pPhysics.syncList[i];

        if (syncData.obj == obj) {

            switch (type) {
            case 'ANGULAR_DAMPING':
                param = syncData.body.getAngularDamping();
                break;
            case 'ANGULAR_FACTOR':
                btVec = syncData.body.getAngularFactor();
                break;
            case 'ANGULAR_VELOCITY':
                btVec = syncData.body.getAngularVelocity();
                break;
            case 'FORCE':
                btVec = syncData.body.getTotalForce();
                break;
            case 'FRICTION':
                param = syncData.body.getFriction(param);
                break;
            case 'GRAVITY':
                btVec = syncData.body.getGravity();
                break;
            case 'LINEAR_DAMPING':
                param = syncData.body.getLinearDamping();
                break;
            case 'LINEAR_FACTOR':
                btVec = syncData.body.getLinearFactor();
                break;
            case 'LINEAR_VELOCITY':
                btVec = syncData.body.getLinearVelocity();
                break;
            case 'POSITION':
                var ms = syncData.body.getMotionState();
                ms.getWorldTransform(_pPhysics.transTmp);
                btVec = _pPhysics.transTmp.getOrigin();
                break;
            case 'RESTITUTION':
                param = syncData.body.getRestitution(param);
                break;
            case 'STIFFNESS':
                if (syncData.type == 'SOFT_BODY')
                    param = syncData.body.get_m_materials().at(0).get_m_kLST(param);
                else
                    console.error('get body param: Stiffness param is not applicable for rigid bodies');
                break;
            case 'TORQUE':
                btVec = syncData.body.getTotalTorque();
                break;
            }

            if (btVec) {
                var vec = _pGlob.vec3Tmp.set(btVec.x(), btVec.y(), btVec.z());
                var noSignChange = (type == 'LINEAR_FACTOR' || type == 'ANGULAR_FACTOR');
                return coordsTransform(vec, 'Y_UP_RIGHT', getCoordSystem(), noSignChange).toArray();
            } else {
                return param;
            }
        }
    }

}



// getVectorValue puzzle
function getVectorValue(vector, value) {

    var vector = _pGlob.vec3Tmp.fromArray(vector);

    switch (value) {
    case 'X':
        return vector.x;
    case 'Y':
        return vector.y;
    case 'Z':
        return vector.z;
    case 'IS_ZERO':
        return Boolean(vector.length() <= Number.EPSILON);
    case 'LENGTH':
        return vector.length();
    case 'NEGATED':
        return [-vector.x, -vector.y, -vector.z];
    case 'NORMALIZED':
        return vector.normalize().toArray();
    default:
        console.error('get value from vector: Wrong value');
        return;
    }
};


// Describe this function...
function map_range(input_range_start, input_range_end, result_range_start, result_range_end, input_value) {
  result_range = (input_range_end - input_range_start) / (result_range_end - result_range_start);
  output_value = (input_value - input_range_start) / result_range + result_range_start;
  return output_value;
}


function matGetValues(matName) {

    var mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
    if (!mat)
        return [];

    if (mat.isMeshNodeMaterial)
        return Object.keys(mat.nodeValueMap);
    else if (mat.isMeshStandardMaterial)
        return ['metalness', 'roughness', 'bumpScale', 'emissiveIntensity', 'envMapIntensity'];
    else
        return [];
}



// setMaterialValue puzzle
function setMaterialValue(matName, valName, value) {

    var values = matGetValues(matName);
    if (values.indexOf(valName) < 0)
        return;

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    for (var i = 0; i < mats.length; i++) {
        var mat = mats[i];

        if (mat.isMeshNodeMaterial) {
            var valIdx = mat.nodeValueMap[valName];
            mat.nodeValue[valIdx] = Number(value);
        } else
            mat[valName] = Number(value);

        if (mat === appInstance.worldMaterial)
            appInstance.updateEnvironment(mat);
    }
}



// snapBody puzzle
function snapBody(objName, targetObjName) {
    if (!objName || !targetObjName)
        return;

    var obj = getObjectByName(objName);
    var targetObj = getObjectByName(targetObjName);
    if (!obj || !targetObj)
        return;

    for (var i = 0; i < _pPhysics.syncList.length; i++) {
        var syncData = _pPhysics.syncList[i];

        if (syncData.obj == obj) {

            // snap verge3d object itself
            obj.copyTransform(targetObj);

            _pPhysics.setObjToBodyTransform(obj, syncData.body);

        }
    }
}


// Describe this function...
function respawn() {
  if (respawn_in_action == false) {
    respawn_in_action = true;
    volume(current_track, 0);
    playSound(loadMedia_WebAudio('./sounds/respawn_transition.mp3'), false);
    changeVis('vignette', true);

    animateParam(25, 0, 1, 'Linear', 'InOut', 0, false,
        function() {
      setMaterialValue('vignette', 'Value', _pGlob.animateParamUpdate);
    },
        function() {
      snapBody('car_body', 'car_respawn');

      animateParam(0, 25, 1, 'Linear', 'InOut', 0, false,
          function() {
        setMaterialValue('vignette', 'Value', _pGlob.animateParamUpdate);
      },
          function() {
        changeVis('vignette', false);
        respawn_in_action = false;
        volume(current_track, 0.1);
      });

          });

        }
}

// Describe this function...
function engine_force_recalc() {
  summ_damage = front_damaged + front_left_damaged + front_right_damaged + rear_damaged + rear_left_damaged + rear_right_damaged;
  maxEngineForce = map_range(0.01, 18, 4000, 100, summ_damage);
}


// setTimer puzzle
function registerSetTimer(id, timeout, callback, repeat) {

    if (id in _pGlob.intervals) {
        window.clearInterval(_pGlob.intervals[id]);
    }

    _pGlob.intervals[id] = window.setInterval(function() {
        if (repeat-- > 0) {
            callback(_pGlob.intervals[id]);
        }
    }, 1000 * timeout);
}



// removeTimer puzzle
function registerRemoveTimer(id) {
    if (id in _pGlob.intervals) {
        window.clearInterval(_pGlob.intervals[id]);
    }
}



// setInterval puzzle
function registerInterval(timeout, callback) {
    var timerId = window.setInterval(function() { callback(timerId) }, 1000 * timeout);
}



// setPlaybackRate puzzle
function setPlaybackRate(mediaElem, rate) {
    if (!mediaElem)
        return;

    rate = Number(rate);
    if (Number.isNaN(rate)) {
        return;
    }

    mediaElem.setPlaybackRate(rate);
}



function MediaHTML5(isVideo) {
    this.source = null;
}

Object.assign(MediaHTML5.prototype, {

    load: function(url, isVideo) {
        if (isVideo) {
            this.source = document.createElement('video');
            this.source.playsInline = true;
            this.source.preload = 'auto';
            this.source.autoload = true;
            this.source.crossOrigin = 'anonymous';
        } else {
            this.source = document.createElement('audio');
        }

        this.source.src = url;
        return this;
    },

    play: function() {
        this.source.play();
    },

    pause: function() {
        this.source.pause();
    },

    stop: function() {
        this.source.pause();
        this.source.currentTime = 0;
    },

    rewind: function() {
        this.source.currentTime = 0;
    },

    setPlaybackRate: function(rate) {
        this.source.playbackRate = rate;
    },

    isPlaying: function() {
        return this.source.duration > 0 && !this.source.paused;
    },

    setLoop: function(looped) {
        this.source.loop = looped;
    },

    setVolume: function(volume) {
        this.source.volume = volume;
    },

    setMuted: function(muted) {
        this.source.muted = muted;
    },

});



// loadMedia puzzle
function loadMedia_HTML5(url) {

    var elems = _pGlob.mediaElements;
    if (!(url in elems)) {
        elems[url] = new MediaHTML5().load(url);
    }
    return elems[url];
}


// Describe this function...
function damage_map_update() {
  setMaterialValue('damage_map', 'front_left', front_left_damaged);
  setMaterialValue('damage_map', 'front_center', front_damaged);
  setMaterialValue('damage_map', 'front_right', front_right_damaged);
  setMaterialValue('damage_map', 'rear_left', rear_left_damaged);
  setMaterialValue('damage_map', 'rear_center', rear_damaged);
  setMaterialValue('damage_map', 'rear_right', rear_right_damaged);
}


// addPhysicsConstraint puzzle
function addPhysicsConstraint(obj1, obj2, type, pivot, axis, stiffness, damping) {
    if (!obj1 || !obj2)
        return;

    var obj1 = getObjectByName(obj1);
    var obj2 = getObjectByName(obj2);
    if (!obj1 || !obj2)
        return;

    _pPhysics.findRemovePhysicsConstraint(obj1, obj2);

    for (var i = 0; i < _pPhysics.syncList.length; i++) {
        var syncData1 = _pPhysics.syncList[i];

        if (syncData1.obj == obj1) {
            for (var j = 0; j < _pPhysics.syncList.length; j++) {
                var syncData2 = _pPhysics.syncList[j];

                if (syncData2.obj == obj2) {

                    var pivot1 = _pGlob.vec3Tmp.fromArray(pivot);
                    pivot1 = coordsTransform(pivot1, getCoordSystem(), 'Y_UP_RIGHT');

                    var pivot2 = _pGlob.vec3Tmp2.copy(pivot1)

                    obj1.worldToLocal(pivot1);
                    obj2.worldToLocal(pivot2);

                    var btPivot1 = new Ammo.btVector3(pivot1.x, pivot1.y, pivot1.z);
                    var btPivot2 = new Ammo.btVector3(pivot2.x, pivot2.y, pivot2.z);

                    var axis1 = _pGlob.vec3Tmp.fromArray(axis);
                    axis1 = coordsTransform(axis1, getCoordSystem(), 'Y_UP_RIGHT');

                    var axis2 = _pGlob.vec3Tmp2.copy(axis1)

                    axis1 = axis1.applyMatrix4(_pGlob.mat4Tmp.copy(obj1.matrixWorld).transpose());
                    axis2 = axis2.applyMatrix4(_pGlob.mat4Tmp.copy(obj2.matrixWorld).transpose());

                    var btAxis1 = new Ammo.btVector3(axis1.x, axis1.y, axis1.z);
                    var btAxis2 = new Ammo.btVector3(axis2.x, axis2.y, axis2.z);

                    var body1 = syncData1.body;
                    var body2 = syncData2.body;

                    switch (type) {
                        case 'HINGE':
                            var cons = new Ammo.btHingeConstraint(body1, body2, btPivot1, btPivot2, btAxis1, btAxis2, true);
                            break;
                        case 'BALL':
                            var cons = new Ammo.btPoint2PointConstraint(body1, body2, btPivot1, btPivot2);
                            break;
                        case 'SLIDER':
                            var trans1 = _pPhysics.transTmp;
                            trans1.setIdentity();
                            trans1.setOrigin(btPivot1);

                            var trans2 = _pPhysics.transTmp2;
                            trans2.setIdentity();
                            trans2.setOrigin(btPivot2);

                            var cons = new Ammo.btSliderConstraint(body1, body2, trans1, trans2, true);
                            break;

                        case 'SPRING':
                            var trans1 = _pPhysics.transTmp;
                            trans1.setIdentity();
                            trans1.setOrigin(btPivot1);

                            var trans2 = _pPhysics.transTmp2;
                            trans2.setIdentity();
                            trans2.setOrigin(btPivot2);

                            var cons = new Ammo.btGeneric6DofSpringConstraint(body1, body2, trans1, trans2, true);

                            // no limits
                            cons.setLinearUpperLimit(new Ammo.btVector3(-1.0, -1.0, -1.0));
                            cons.setLinearLowerLimit(new Ammo.btVector3(1.0, 1.0, 1.0));

                            // no rotation
                            cons.setAngularLowerLimit(new Ammo.btVector3(0.0, 0.0, 0));
                            cons.setAngularUpperLimit(new Ammo.btVector3(0.0, 0.0, 0));

                            cons.enableSpring(0, true);
                            cons.enableSpring(1, true);
                            cons.enableSpring(2, true);
                            cons.setStiffness(0, stiffness);
                            cons.setStiffness(1, stiffness);
                            cons.setStiffness(2, stiffness);
                            cons.setDamping(0, damping);
                            cons.setDamping(1, damping);
                            cons.setDamping(2, damping);

                            cons.setEquilibriumPoint();

                            break;

                        case 'FIXED':
                            var trans1 = _pPhysics.transTmp;
                            var transMat = _pGlob.mat4Tmp.getInverse(obj1.matrixWorld).multiply(obj2.matrixWorld);
                            trans1.setFromOpenGLMatrix(transMat.elements);

                            var trans2 = _pPhysics.transTmp2;
                            trans2.setIdentity();

                            var cons = new Ammo.btFixedConstraint(body1, body2, trans1, trans2);
                            break;
                    }

                    _pPhysics.world.addConstraint(cons, true);

                    _pPhysics.consList.push({
                        cons: cons,
                        obj1: obj1,
                        obj2: obj2,
                        body1: body1,
                        body2: body2
                    });

                    if (v3d.PL) {
                        v3d.PL.physics.constraints[obj1.name] = v3d.PL.physics.constraints[obj1.name] || {};
                        v3d.PL.physics.constraints[obj1.name][obj2.name] = cons;
                    }

                }
            }
        }
    }
}



// getObjDirection puzzle
function getObjDirection(objName, coord) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;

    var dir = obj.getWorldDirection(_pGlob.vec3Tmp);

    var coordSystem = getCoordSystem();
    coordsTransform(dir, 'Y_UP_RIGHT', coordSystem);

    switch (coord) {
    case 'X':
        return dir.x;
    case 'Y':
        return dir.y;
    case 'Z':
        return dir.z;
    case 'XYZ':
        return dir.toArray();
    case 'HORIZONTAL':
        switch (coordSystem) {
        case 'Y_UP_RIGHT':
            dir.y = 0;
            dir.normalize();
            return [dir.x, 0, dir.z];
        default:
            dir.z = 0;
            dir.normalize();
            return [dir.x, dir.y, 0];
        }
    default:
        console.error("get object direction: Wrong coords");
        return;
    }
};



// createVector puzzle
function createVector(x, y, z) {
    return [x, y, z];
};


function mathRandomInt(a, b) {
  if (a > b) {
    // Swap a and b to ensure a is smaller.
    var c = a;
    a = b;
    b = c;
  }
  return Math.floor(Math.random() * (b - a + 1) + a);
}

// Describe this function...
function recalculate_checkpoint() {
  next_checkpoint = ['checkpoint_',current_checkpoint + 1,'_',Math.round(mathRandomInt(1, 3))].join('');
}

// Describe this function...
function race_restart() {
  current_checkpoint = 0;
  checkpoint_touch_start = false;
  recalculate_checkpoint();
  snapToObject('checkpoint', next_checkpoint);
  checkpoint_total_time = 0;
  changeVis('start_counter', false);
  changeVis('checkpoint_pointer', true);
  race_started = true;
  changeVis('checkpoint', true);
  changeVis(['minutes_counter_1', 'minutes_counter_2', 'seconds_couner_1', 'seconds_couner_2', 'colon'], true);
  changeVis('start', true);
  playSound(loadMedia_WebAudio('./sounds/race_begin.mp3'), false);
  registerSetTimeout(2, function() {
    changeVis('start', false);
  });
  no_count = true;
  start_counter = 0;
  setMaterialValue('start_counter', 'Value', start_counter);
  interface_recalc();
}


// convertToNumber puzzle
function toNumber(text) {
    var num = Number(text);
    if (isNaN(num))
        num = 0;
    return num;
}


// Describe this function...
function press_r_or_bouble_tap() {
  changeVis('press_r', false);
  changeVis('double_tap', false);
  press_r = false;
  changeVis('start_counter', true);
  snapBody('car_body', 'car_respawn');
  start_counter = 0;
  no_count = false;
  car_repair();
  registerSetTimeout(4, function() {
    checkpoint_minutes = 0;
    checkpoint_seconds = 0;
    race_restart();
  });
}


// addHTMLElement puzzle
function addHTMLElement(elemType, id, mode, targetId, isParent) {

    var win = isParent ? window.parent : window;

    var elem = win.document.createElement(elemType);
    if (id !== '')
        elem.id = id;

    var targetElem = getElement(targetId, isParent);
    if (targetElem instanceof win.Element) {
        switch (mode) {
            case 'TO':
                targetElem.appendChild(elem);
                break;
            case 'BEFORE':
                targetElem.insertAdjacentElement('beforebegin', elem);
                break;
            case 'AFTER':
                targetElem.insertAdjacentElement('afterend', elem);
                break;
        }
    }
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}


// Describe this function...
function change_track() {
  random_track_number();
  if (random_number == 1) {
    current_track = track_1;
    current_track_number = 1;
  } else if (random_number == 2) {
    current_track = track_2;
    current_track_number = 2;
  } else if (random_number == 3) {
    current_track = track_3;
    current_track_number = 3;
  }
  playSound(current_track, false);
}

// Describe this function...
function random_track_number() {
  random_number = Math.round(mathRandomInt(1, 3));
  if (current_track_number == random_number) {
    random_track_number();
  }
}


setScreenScale(window.devicePixelRatio / 2);
interface_recalc();
rotate_your_device_message();

game_started = false;
tweenCamera('camera_start_point', 'look_at_point', 0, function() {}, 0);


// createPhysicsWorld puzzle

// TEMPORARY MEASURE TO PREVENT CRASH [TODO]
if (window.Ammo) {

var CF_STATIC_OBJECT = 1;
var CF_KINEMATIC_OBJECT = 2;
var CF_NO_CONTACT_RESPONSE = 4;

var ACTIVE_TAG = 1;
var ISLAND_SLEEPING = 2;
var DISABLE_DEACTIVATION = 4;
var DISABLE_SIMULATION = 5;

var RO_XYZ = 0;

// collision filter groups
var DefaultFilter = 1;
var StaticFilter = 2;
var KinematicFilter = 4;
var DebrisFilter = 8;
var SensorTrigger = 16;
var CharacterFilter = 32;
var AllFilter = -1;

if (false) {

    _pPhysics.collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
    _pPhysics.dispatcher = new Ammo.btCollisionDispatcher(_pPhysics.collisionConfiguration);
    _pPhysics.broadphase = new Ammo.btDbvtBroadphase();
    _pPhysics.solver = new Ammo.btSequentialImpulseConstraintSolver();
    _pPhysics.softBodySolver = new Ammo.btDefaultSoftBodySolver();
    _pPhysics.world = new Ammo.btSoftRigidDynamicsWorld(_pPhysics.dispatcher, _pPhysics.broadphase,
            _pPhysics.solver, _pPhysics.collisionConfiguration, _pPhysics.softBodySolver);
    _pPhysics.world.getWorldInfo().set_m_gravity(new Ammo.btVector3(0, -9.8, 0));

    _pPhysics.softBodyHelpers = new Ammo.btSoftBodyHelpers();

} else {

    _pPhysics.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
    _pPhysics.dispatcher = new Ammo.btCollisionDispatcher(_pPhysics.collisionConfiguration);
    _pPhysics.broadphase = new Ammo.btDbvtBroadphase();
    _pPhysics.solver = new Ammo.btSequentialImpulseConstraintSolver();
    _pPhysics.world = new Ammo.btDiscreteDynamicsWorld(_pPhysics.dispatcher, _pPhysics.broadphase,
            _pPhysics.solver, _pPhysics.collisionConfiguration);

}

_pPhysics.world.setGravity( new Ammo.btVector3( 0, -9.8, 0 ) );
_pPhysics.fps = 120;
_pPhysics.transTmp = new Ammo.btTransform();
_pPhysics.transTmp2 = new Ammo.btTransform();

// external physics interface
if (v3d.PL) {
    v3d.PL.physics = v3d.PL.physics || {};
    v3d.PL.physics.world = _pPhysics.world;
    v3d.PL.physics.bodies = {};
    v3d.PL.physics.constraints = {};
    v3d.PL.physics.addToSyncList = function(obj, body, type) {
        _pPhysics.syncList.push({
            obj: obj,
            body: body,
            type: type,
            simulated: true,
            mass: (body.getInvMass() !==0) ? 1.0/body.getInvMass() : 0
        });
        v3d.PL.physics.bodies[obj.name] = body;
    }
    v3d.PL.physics.removeFromSyncList = function(obj, body) {
        _pPhysics.findRemovePhysicsBody(obj);
        delete v3d.PL.physics.bodies[obj.name];
    }
}

function tick(dt) {

    var DISTANCE_EPSILON = 0.000001;

    if (_pPhysics.collisionData.length) {

        var numManifolds = _pPhysics.world.getDispatcher().getNumManifolds();

        for (var i = 0; i < numManifolds; i++) {
            var contactManifold = _pPhysics.world.getDispatcher().getManifoldByIndexInternal(i);

            var bodyA = Ammo.castObject(contactManifold.getBody0(), Ammo.btRigidBody);
            var bodyB = Ammo.castObject(contactManifold.getBody1(), Ammo.btRigidBody);

            var collDataMatch = null;
            var objsSwapped = false;

            for (var j = 0; j < _pPhysics.collisionData.length; j++) {
                var cd = _pPhysics.collisionData[j];

                if (cd.bodyA == bodyA && cd.bodyB == bodyB) {
                    collDataMatch = cd;
                    break;
                }

                if (cd.bodyA == bodyB && cd.bodyB == bodyA) {
                    collDataMatch = cd;
                    objsSwapped = true;
                    break;
                }
            }

            if (!collDataMatch)
                continue;

            var numContacts = contactManifold.getNumContacts();

            for (var j = 0; j < numContacts; j++) {
                var pt = contactManifold.getContactPoint(j);

                if (pt.getDistance() < DISTANCE_EPSILON) {
                    var ptA = pt.getPositionWorldOnA();
                    var ptB = pt.getPositionWorldOnB();
                    var noB = pt.get_m_normalWorldOnB();

                    _pPhysics.collisionInfo.objectA = collDataMatch.objA ? getPickedObjectName(collDataMatch.objA) : '';
                    _pPhysics.collisionInfo.objectB = collDataMatch.objB ? getPickedObjectName(collDataMatch.objB) : '';

                    _pPhysics.collisionInfo.distance = pt.getDistance();

                    if (!objsSwapped) {
                        _pPhysics.collisionInfo.positionOnA[0] = ptA.x();
                        _pPhysics.collisionInfo.positionOnA[1] = ptA.y();
                        _pPhysics.collisionInfo.positionOnA[2] = ptA.z();

                        _pPhysics.collisionInfo.positionOnB[0] = ptB.x();
                        _pPhysics.collisionInfo.positionOnB[1] = ptB.y();
                        _pPhysics.collisionInfo.positionOnB[2] = ptB.z();

                        _pPhysics.collisionInfo.normalOnB[0] = noB.x();
                        _pPhysics.collisionInfo.normalOnB[1] = noB.y();
                        _pPhysics.collisionInfo.normalOnB[2] = noB.z();
                    } else {
                        _pPhysics.collisionInfo.positionOnA[0] = ptB.x();
                        _pPhysics.collisionInfo.positionOnA[1] = ptB.y();
                        _pPhysics.collisionInfo.positionOnA[2] = ptB.z();

                        _pPhysics.collisionInfo.positionOnB[0] = ptA.x();
                        _pPhysics.collisionInfo.positionOnB[1] = ptA.y();
                        _pPhysics.collisionInfo.positionOnB[2] = ptA.z();

                        _pPhysics.collisionInfo.normalOnB[0] = -noB.x();
                        _pPhysics.collisionInfo.normalOnB[1] = -noB.y();
                        _pPhysics.collisionInfo.normalOnB[2] = -noB.z();
                    }

                    collDataMatch.collideCb();

                    // mark as collided all collision data from the same exec instance
                    for (var k = 0; k < _pPhysics.collisionData.length; k++) {
                        var cd = _pPhysics.collisionData[k];
                        if (cd.execInstanceID == collDataMatch.execInstanceID) {
                            cd.collideFlag = true;
                        }
                    }
                }
            }
        }

        for (var i = 0; i < _pPhysics.collisionData.length; i++) {
            var cd = _pPhysics.collisionData[i];

            if (!cd.collideFlag) {
                _pPhysics.collisionInfo.objectA = '';
                _pPhysics.collisionInfo.objectB = '';

                _pPhysics.collisionInfo.distance = 0;

                _pPhysics.collisionInfo.positionOnA[0] = 0;
                _pPhysics.collisionInfo.positionOnA[1] = 0;
                _pPhysics.collisionInfo.positionOnA[2] = 0;

                _pPhysics.collisionInfo.positionOnB[0] = 0;
                _pPhysics.collisionInfo.positionOnB[1] = 0;
                _pPhysics.collisionInfo.positionOnB[2] = 0;

                _pPhysics.collisionInfo.normalOnB[0] = 0;
                _pPhysics.collisionInfo.normalOnB[1] = 0;
                _pPhysics.collisionInfo.normalOnB[2] = 0;

                cd.noCollideCb();

                // no need to process other collision data from the same exec instance
                for (var j = i+1; j < _pPhysics.collisionData.length; j++) {
                    var cdj = _pPhysics.collisionData[j];
                    if (cdj.execInstanceID == cd.execInstanceID) {
                        cdj.collideFlag = true;
                    }
                }
            }

            cd.collideFlag = false;
        }
    }

    _pPhysics.world.stepSimulation(dt, 10, 1/120);

    // sync physics and graphics

    for (var i = 0; i < _pPhysics.syncList.length; i++) {
        var syncData = _pPhysics.syncList[i];
        if (!syncData.simulated)
            continue;

        var body = syncData.body;

        if (syncData.type == 'SOFT_BODY') {

            var geometry = syncData.obj.geometry;
            var volumePositions = geometry.attributes.position.array;
            var volumeNormals = geometry.ammoNeedNormals ? geometry.attributes.normal.array : null;

            var association = geometry.ammoIndexAssociation;
            var numVerts = association.length;
            var nodes = body.get_m_nodes();

            for (var j = 0; j < numVerts; j++) {

                var node = nodes.at(j);

                var nodePos = node.get_m_x();
                var x = nodePos.x();
                var y = nodePos.y();
                var z = nodePos.z();

                if (volumeNormals) {
                    var nodeNormal = node.get_m_n();
                    var nx = nodeNormal.x();
                    var ny = nodeNormal.y();
                    var nz = nodeNormal.z();
                }

                var assocVertex = association[j];

                for (var k = 0, kl = assocVertex.length; k < kl; k++) {

                    var indexVertex = assocVertex[k];
                    volumePositions[indexVertex] = x;
                    if (volumeNormals)
                        volumeNormals[indexVertex] = nx;

                    indexVertex++;
                    volumePositions[indexVertex] = y;
                    if (volumeNormals)
                        volumeNormals[indexVertex] = ny;

                    indexVertex++;
                    volumePositions[indexVertex] = z;
                    if (volumeNormals)
                        volumeNormals[indexVertex] = nz;

                }

            }

            geometry.attributes.position.needsUpdate = true;
            if (volumeNormals)
                geometry.attributes.normal.needsUpdate = true;

            if (geometry.attributes.previous) {
                v3d.MeshLine.updateAttributes(geometry);
            }

        } else if (!body.isStaticOrKinematicObject()) {
            var ms = body.getMotionState();
            if (ms) {
                ms.getWorldTransform(_pPhysics.transTmp);
                var p = _pPhysics.transTmp.getOrigin();
                var q = _pPhysics.transTmp.getRotation();
                // dynamic objects can't be parented to something
                syncData.obj.position.set(p.x(), p.y(), p.z());
                syncData.obj.quaternion.set(q.x(), q.y(), q.z(), q.w());
            }

        } else if (body.isKinematicObject()) {

            var pos = syncData.obj.getWorldPosition(_pGlob.vec3Tmp);
            var quat = syncData.obj.getWorldQuaternion(_pGlob.quatTmp);

            _pPhysics.transTmp.setIdentity();
            _pPhysics.transTmp.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
            _pPhysics.transTmp.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));

            body.setWorldTransform(_pPhysics.transTmp);

            // needed to calculate interpolated velocity
            body.getMotionState().setWorldTransform(_pPhysics.transTmp);

        }
    }

}

appInstance.renderCallbacks.push(tick);

// END OF TEMPORARY MEASURE TO PREVENT CRASH [TODO]
}


sound_breaking_skid = loadMedia_WebAudio('./sounds/breaking_skid.mp3');
sound_base_engine = loadMedia_WebAudio('./sounds/engine_base_sound.mp3');
volume(sound_base_engine, 0.5);
volume(loadMedia_WebAudio('./sounds/engine_start.mp3'), 0.5);
volume(sound_breaking_skid, 0);

steeringIncrement_multiplier = 1;
registerEveryFrame(function() {
  if (car_speed < 80) {
    steeringIncrement = map_range(0, 80, 0.01, 0.005, car_speed) * steeringIncrement_multiplier;
    steeringClamp = map_range(0, 80, 0.3, 0.1, car_speed);
  }
});

steeringIncrement = 0.01;
steeringClamp = 0.3;
maxEngineForce = 4000;
maxBreakingForce = 20;
syncVehicleCallback = null;

setHTMLElemAttribute('style', 'touch-action:none;', ['CONTAINER'], false);

actions = {};
eventHTMLElem('keydown', ['DOCUMENT'], false, function(event) {
  if (game_started == true) {
    if (getEventProperty('code', event) == 'KeyW') {
      dictSet(actions, 'acceleration', true);
    } else if (getEventProperty('code', event) == 'KeyS') {
      dictSet(actions, 'braking', true);
    } else if (getEventProperty('code', event) == 'KeyA') {
      dictSet(actions, 'left', true);
      moving_side = 'left';
    } else if (getEventProperty('code', event) == 'KeyD') {
      dictSet(actions, 'right', true);
      moving_side = 'right';
    } else if (getEventProperty('key', event) == ' ') {
      maxBreakingForce = map_range(0.01, 18, 60, 25, summ_damage);
      maxEngineForce = 0;
      dictSet(actions, 'braking', true);
    }
  }
});
eventHTMLElem('keyup', ['DOCUMENT'], false, function(event) {
  if (game_started == true) {
    if (getEventProperty('code', event) == 'KeyW') {
      dictSet(actions, 'acceleration', false);
    } else if (getEventProperty('code', event) == 'KeyS') {
      dictSet(actions, 'braking', false);
    } else if (getEventProperty('code', event) == 'KeyA') {
      dictSet(actions, 'left', false);
    } else if (getEventProperty('code', event) == 'KeyD') {
      dictSet(actions, 'right', false);
    } else if (getEventProperty('key', event) == ' ') {
      dictSet(actions, 'braking', false);
      maxBreakingForce = map_range(0.01, 18, 20, 5, summ_damage);
      engine_force_recalc();
    }
    moving_side = 'none';
  }
});

var VARS = Object.defineProperties({}, {
    "game_started": { get: function() { return game_started; }, set: function(val) { game_started = val; } },
    "sound_breaking_skid": { get: function() { return sound_breaking_skid; }, set: function(val) { sound_breaking_skid = val; } },
    "steeringIncrement_multiplier": { get: function() { return steeringIncrement_multiplier; }, set: function(val) { steeringIncrement_multiplier = val; } },
    "steeringIncrement": { get: function() { return steeringIncrement; }, set: function(val) { steeringIncrement = val; } },
    "actions": { get: function() { return actions; }, set: function(val) { actions = val; } },
    "camera_moving_speed": { get: function() { return camera_moving_speed; }, set: function(val) { camera_moving_speed = val; } },
    "help_shown": { get: function() { return help_shown; }, set: function(val) { help_shown = val; } },
    "sound_base_engine": { get: function() { return sound_base_engine; }, set: function(val) { sound_base_engine = val; } },
    "steeringClamp": { get: function() { return steeringClamp; }, set: function(val) { steeringClamp = val; } },
    "screen_ratio": { get: function() { return screen_ratio; }, set: function(val) { screen_ratio = val; } },
    "maxEngineForce": { get: function() { return maxEngineForce; }, set: function(val) { maxEngineForce = val; } },
    "maxBreakingForce": { get: function() { return maxBreakingForce; }, set: function(val) { maxBreakingForce = val; } },
    "input_range_start": { get: function() { return input_range_start; }, set: function(val) { input_range_start = val; } },
    "input_range_end": { get: function() { return input_range_end; }, set: function(val) { input_range_end = val; } },
    "result_range_start": { get: function() { return result_range_start; }, set: function(val) { result_range_start = val; } },
    "result_range_end": { get: function() { return result_range_end; }, set: function(val) { result_range_end = val; } },
    "input_value": { get: function() { return input_value; }, set: function(val) { input_value = val; } },
    "car_speed": { get: function() { return car_speed; }, set: function(val) { car_speed = val; } },
    "syncVehicleCallback": { get: function() { return syncVehicleCallback; }, set: function(val) { syncVehicleCallback = val; } },
    "moving_side": { get: function() { return moving_side; }, set: function(val) { moving_side = val; } },
    "race_started": { get: function() { return race_started; }, set: function(val) { race_started = val; } },
    "summ_damage": { get: function() { return summ_damage; }, set: function(val) { summ_damage = val; } },
    "start_counter": { get: function() { return start_counter; }, set: function(val) { start_counter = val; } },
    "dead_zone_start": { get: function() { return dead_zone_start; }, set: function(val) { dead_zone_start = val; } },
    "building_collisions": { get: function() { return building_collisions; }, set: function(val) { building_collisions = val; } },
    "repair_shop_start": { get: function() { return repair_shop_start; }, set: function(val) { repair_shop_start = val; } },
    "paint_shop_green_start": { get: function() { return paint_shop_green_start; }, set: function(val) { paint_shop_green_start = val; } },
    "buildings": { get: function() { return buildings; }, set: function(val) { buildings = val; } },
    "paint_shop_orange_start": { get: function() { return paint_shop_orange_start; }, set: function(val) { paint_shop_orange_start = val; } },
    "bl_j": { get: function() { return bl_j; }, set: function(val) { bl_j = val; } },
    "paint_shop_blue_start": { get: function() { return paint_shop_blue_start; }, set: function(val) { paint_shop_blue_start = val; } },
    "front_damaged": { get: function() { return front_damaged; }, set: function(val) { front_damaged = val; } },
    "front_right_damaged": { get: function() { return front_right_damaged; }, set: function(val) { front_right_damaged = val; } },
    "front_left_damaged": { get: function() { return front_left_damaged; }, set: function(val) { front_left_damaged = val; } },
    "rear_damaged": { get: function() { return rear_damaged; }, set: function(val) { rear_damaged = val; } },
    "rear_left_damaged": { get: function() { return rear_left_damaged; }, set: function(val) { rear_left_damaged = val; } },
    "rear_right_damaged": { get: function() { return rear_right_damaged; }, set: function(val) { rear_right_damaged = val; } },
    "barrel_hit_start": { get: function() { return barrel_hit_start; }, set: function(val) { barrel_hit_start = val; } },
    "static_props_collisions": { get: function() { return static_props_collisions; }, set: function(val) { static_props_collisions = val; } },
    "tyres": { get: function() { return tyres; }, set: function(val) { tyres = val; } },
    "furniture_hit_start": { get: function() { return furniture_hit_start; }, set: function(val) { furniture_hit_start = val; } },
    "cacti_hit_start": { get: function() { return cacti_hit_start; }, set: function(val) { cacti_hit_start = val; } },
    "traffic_cone_hit_start": { get: function() { return traffic_cone_hit_start; }, set: function(val) { traffic_cone_hit_start = val; } },
    "cacti_mesh": { get: function() { return cacti_mesh; }, set: function(val) { cacti_mesh = val; } },
    "barrels": { get: function() { return barrels; }, set: function(val) { barrels = val; } },
    "static_props": { get: function() { return static_props; }, set: function(val) { static_props = val; } },
    "pl_i": { get: function() { return pl_i; }, set: function(val) { pl_i = val; } },
    "furniture": { get: function() { return furniture; }, set: function(val) { furniture = val; } },
    "cacti_capsule": { get: function() { return cacti_capsule; }, set: function(val) { cacti_capsule = val; } },
    "traffic_cones": { get: function() { return traffic_cones; }, set: function(val) { traffic_cones = val; } },
    "j": { get: function() { return j; }, set: function(val) { j = val; } },
    "sound_glass_crash": { get: function() { return sound_glass_crash; }, set: function(val) { sound_glass_crash = val; } },
    "list_of_speed_current": { get: function() { return list_of_speed_current; }, set: function(val) { list_of_speed_current = val; } },
    "respawn_in_action": { get: function() { return respawn_in_action; }, set: function(val) { respawn_in_action = val; } },
    "for_damage_list": { get: function() { return for_damage_list; }, set: function(val) { for_damage_list = val; } },
    "front_damage_start": { get: function() { return front_damage_start; }, set: function(val) { front_damage_start = val; } },
    "respawn_set": { get: function() { return respawn_set; }, set: function(val) { respawn_set = val; } },
    "car_body_hit_start": { get: function() { return car_body_hit_start; }, set: function(val) { car_body_hit_start = val; } },
    "sound_front_crash": { get: function() { return sound_front_crash; }, set: function(val) { sound_front_crash = val; } },
    "list_of_speed": { get: function() { return list_of_speed; }, set: function(val) { list_of_speed = val; } },
    "result_range": { get: function() { return result_range; }, set: function(val) { result_range = val; } },
    "output_value": { get: function() { return output_value; }, set: function(val) { output_value = val; } },
    "front_right_damage_start": { get: function() { return front_right_damage_start; }, set: function(val) { front_right_damage_start = val; } },
    "front_left_damage_start": { get: function() { return front_left_damage_start; }, set: function(val) { front_left_damage_start = val; } },
    "car_down": { get: function() { return car_down; }, set: function(val) { car_down = val; } },
    "car_drop_start": { get: function() { return car_drop_start; }, set: function(val) { car_drop_start = val; } },
    "rear_damage_start": { get: function() { return rear_damage_start; }, set: function(val) { rear_damage_start = val; } },
    "rear_right_damage_start": { get: function() { return rear_right_damage_start; }, set: function(val) { rear_right_damage_start = val; } },
    "rear_left_damge_start": { get: function() { return rear_left_damge_start; }, set: function(val) { rear_left_damge_start = val; } },
    "sound_right_crash": { get: function() { return sound_right_crash; }, set: function(val) { sound_right_crash = val; } },
    "car_stopped": { get: function() { return car_stopped; }, set: function(val) { car_stopped = val; } },
    "sound_left_crash": { get: function() { return sound_left_crash; }, set: function(val) { sound_left_crash = val; } },
    "list_of_height": { get: function() { return list_of_height; }, set: function(val) { list_of_height = val; } },
    "car_x_rotation": { get: function() { return car_x_rotation; }, set: function(val) { car_x_rotation = val; } },
    "car_falling": { get: function() { return car_falling; }, set: function(val) { car_falling = val; } },
    "current_track": { get: function() { return current_track; }, set: function(val) { current_track = val; } },
    "car_y_rotation": { get: function() { return car_y_rotation; }, set: function(val) { car_y_rotation = val; } },
    "list_of_speed_i": { get: function() { return list_of_speed_i; }, set: function(val) { list_of_speed_i = val; } },
    "list_of_height_current": { get: function() { return list_of_height_current; }, set: function(val) { list_of_height_current = val; } },
    "car_height": { get: function() { return car_height; }, set: function(val) { car_height = val; } },
    "list_of_height_i": { get: function() { return list_of_height_i; }, set: function(val) { list_of_height_i = val; } },
    "playground_props": { get: function() { return playground_props; }, set: function(val) { playground_props = val; } },
    "gates": { get: function() { return gates; }, set: function(val) { gates = val; } },
    "gates_hit_start": { get: function() { return gates_hit_start; }, set: function(val) { gates_hit_start = val; } },
    "gt_i": { get: function() { return gt_i; }, set: function(val) { gt_i = val; } },
    "next_checkpoint": { get: function() { return next_checkpoint; }, set: function(val) { next_checkpoint = val; } },
    "current_checkpoint": { get: function() { return current_checkpoint; }, set: function(val) { current_checkpoint = val; } },
    "checkpoint_touch_start": { get: function() { return checkpoint_touch_start; }, set: function(val) { checkpoint_touch_start = val; } },
    "checkpoint_seconds": { get: function() { return checkpoint_seconds; }, set: function(val) { checkpoint_seconds = val; } },
    "checkpoint_minutes": { get: function() { return checkpoint_minutes; }, set: function(val) { checkpoint_minutes = val; } },
    "press_r": { get: function() { return press_r; }, set: function(val) { press_r = val; } },
    "no_count": { get: function() { return no_count; }, set: function(val) { no_count = val; } },
    "checkpoint_total_time": { get: function() { return checkpoint_total_time; }, set: function(val) { checkpoint_total_time = val; } },
    "touch_1_busy": { get: function() { return touch_1_busy; }, set: function(val) { touch_1_busy = val; } },
    "mono_rotate_on": { get: function() { return mono_rotate_on; }, set: function(val) { mono_rotate_on = val; } },
    "maxBreakingForce_multiplier": { get: function() { return maxBreakingForce_multiplier; }, set: function(val) { maxBreakingForce_multiplier = val; } },
    "touch_1_base_x": { get: function() { return touch_1_base_x; }, set: function(val) { touch_1_base_x = val; } },
    "touch_1_x_length": { get: function() { return touch_1_x_length; }, set: function(val) { touch_1_x_length = val; } },
    "touch_2_base_x": { get: function() { return touch_2_base_x; }, set: function(val) { touch_2_base_x = val; } },
    "touch_2_x_length": { get: function() { return touch_2_x_length; }, set: function(val) { touch_2_x_length = val; } },
    "touch_1_base_y": { get: function() { return touch_1_base_y; }, set: function(val) { touch_1_base_y = val; } },
    "touch_1_y_length": { get: function() { return touch_1_y_length; }, set: function(val) { touch_1_y_length = val; } },
    "track_1": { get: function() { return track_1; }, set: function(val) { track_1 = val; } },
    "track_2": { get: function() { return track_2; }, set: function(val) { track_2 = val; } },
    "random_number": { get: function() { return random_number; }, set: function(val) { random_number = val; } },
    "track_3": { get: function() { return track_3; }, set: function(val) { track_3 = val; } },
    "current_track_number": { get: function() { return current_track_number; }, set: function(val) { current_track_number = val; } },
});

Function('app', 'v3d', 'VARS', 'PROC', (('// - Global variables -' + '\n' +
'var DISABLE_DEACTIVATION = 4;' + '\n' +
'var ZERO_QUATERNION = new v3d.Quaternion(0, 0, 0, 1);' + '\n' +
'' + '\n' +
'var physicsWorld = v3d.puzzles.physics.world;' + '\n' +
'' + '\n' +
'// used to control vehicle' + '\n' +
'if (app.controls)' + '\n' +
'    app.controls.enableKeys = false;' + '\n' +
'' + '\n' +
'// Wheels' + '\n' +
'var FRONT_LEFT = 0;' + '\n' +
'var FRONT_RIGHT = 1;' + '\n' +
'var BACK_LEFT = 2;' + '\n' +
'var BACK_RIGHT = 3;' + '\n' +
'' + '\n' +
'// Graphics variables' + '\n' +
'var materialInteractive = new v3d.MeshPhongMaterial( { color:0x990000 } );' + '\n' +
'' + '\n' +
'function getWheelMesh(index) {' + '\n' +
'    switch (index) {' + '\n' +
'        case FRONT_LEFT:' + '\n' +
'            return app.scene.getObjectByName(\'wheel_front_left\');' + '\n' +
'        case FRONT_RIGHT:' + '\n' +
'            return app.scene.getObjectByName(\'wheel_front_right\');' + '\n' +
'        case BACK_LEFT:' + '\n' +
'            return app.scene.getObjectByName(\'wheel_rear_left\');' + '\n' +
'        case BACK_RIGHT:' + '\n' +
'            return app.scene.getObjectByName(\'wheel_rear_right\');' + '\n' +
'    }' + '\n' +
'}' + '\n' +
'' + '\n' +
'function createVehicle(pos, quat) {' + '\n' +
'' + '\n' +
'    // Vehicle contants' + '\n' +
'' + '\n' +
'    var chassisWidth = 1.0;' + '\n' +
'    var chassisHeight = 0.4;' + '\n' +
'    var chassisLength = 3.6;' + '\n' +
'    var massVehicle = 800;' + '\n' +
'' + '\n' +
'    var wheelAxisPositionFront = 1.15;' + '\n' +
'    var wheelRadiusFront = 0.3;' + '\n' +
'    var wheelWidthFront = 0.2;' + '\n' +
'    var wheelHalfTrackFront = 0.65;' + '\n' +
'    var wheelAxisHeightFront = 0.25;' + '\n' +
'' + '\n' +
'    var wheelAxisPositionBack = -1.05;' + '\n' +
'    var wheelRadiusBack = 0.3;' + '\n' +
'    var wheelWidthBack = 0.2;' + '\n' +
'    var wheelHalfTrackBack = 0.65;' + '\n' +
'    var wheelAxisHeightBack = 0.25;' + '\n' +
'' + '\n' +
'    var friction = 1000;' + '\n' +
'    var suspensionStiffness = 30.0;' + '\n' +
'    var suspensionDamping = 2.3;' + '\n' +
'    var suspensionCompression = 2;' + '\n' +
'    var suspensionRestLength = 0.6;' + '\n' +
'    var rollInfluence = 0.01;' + '\n' +
'' + '\n' +
'    // Chassis' + '\n' +
'    var geometry = new Ammo.btBoxShape(new Ammo.btVector3(chassisWidth * 0.5, chassisHeight * 0.5, chassisLength * 0.5));' + '\n' +
'    var transform = new Ammo.btTransform();' + '\n' +
'    transform.setIdentity();' + '\n' +
'    transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));' + '\n' +
'    transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));' + '\n' +
'    var motionState = new Ammo.btDefaultMotionState(transform);' + '\n' +
'    var localInertia = new Ammo.btVector3(0, 0, 0);' + '\n' +
'    geometry.calculateLocalInertia(massVehicle, localInertia);' + '\n' +
'    var body = new Ammo.btRigidBody(new Ammo.btRigidBodyConstructionInfo(massVehicle, motionState, geometry, localInertia));' + '\n' +
'    body.setActivationState(DISABLE_DEACTIVATION);' + '\n' +
'    physicsWorld.addRigidBody(body);' + '\n' +
'    body.setDamping(0.2, 0.0);' + '\n' +
'    var chassisMesh = app.scene.getObjectByName(\'car_body\');' + '\n' +
'    ' + '\n' +
'    v3d.puzzles.physics.addToSyncList(chassisMesh, body, \'DYNAMIC\');' + '\n' +
'' + '\n' +
'    // Raycast Vehicle' + '\n' +
'    var engineForce = 0;' + '\n' +
'    var vehicleSteering = 0;' + '\n' +
'    var breakingForce = 0;' + '\n' +
'    var tuning = new Ammo.btVehicleTuning();' + '\n' +
'    var rayCaster = new Ammo.btDefaultVehicleRaycaster(physicsWorld);' + '\n' +
'    var vehicle = new Ammo.btRaycastVehicle(tuning, body, rayCaster);' + '\n' +
'    vehicle.setCoordinateSystem(0, 1, 2);' + '\n' +
'    physicsWorld.addAction(vehicle);' + '\n' +
'' + '\n' +
'    var wheelMeshes = [];' + '\n' +
'    var wheelDirectionCS0 = new Ammo.btVector3(0, -1, 0);' + '\n' +
'    ' + '\n' +
'    function addWheel(isFront, pos, radius, width, index) {' + '\n' +
'        var wheelAxleCS = new Ammo.btVector3(-1, 0, 0);' + '\n' +
'' + '\n' +
'        var wheelInfo = vehicle.addWheel(' + '\n' +
'                pos,' + '\n' +
'                wheelDirectionCS0,' + '\n' +
'                wheelAxleCS,' + '\n' +
'                suspensionRestLength,' + '\n' +
'                radius,' + '\n' +
'                tuning,' + '\n' +
'                isFront);' + '\n' +
'' + '\n' +
'        wheelInfo.set_m_suspensionStiffness(suspensionStiffness);' + '\n' +
'        wheelInfo.set_m_wheelsDampingRelaxation(suspensionDamping);' + '\n' +
'        wheelInfo.set_m_wheelsDampingCompression(suspensionCompression);' + '\n' +
'        wheelInfo.set_m_frictionSlip(friction);' + '\n' +
'        wheelInfo.set_m_rollInfluence(rollInfluence);' + '\n' +
'' + '\n' +
'        wheelMeshes[index] = getWheelMesh(index);' + '\n' +
'    }' + '\n' +
'' + '\n' +
'    addWheel(true, new Ammo.btVector3(wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisPositionFront), wheelRadiusFront, wheelWidthFront, FRONT_LEFT);' + '\n' +
'    addWheel(true, new Ammo.btVector3(-wheelHalfTrackFront, wheelAxisHeightFront, wheelAxisPositionFront), wheelRadiusFront, wheelWidthFront, FRONT_RIGHT);' + '\n' +
'    addWheel(false, new Ammo.btVector3(wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_LEFT);' + '\n' +
'    addWheel(false, new Ammo.btVector3(-wheelHalfTrackBack, wheelAxisHeightBack, wheelAxisPositionBack), wheelRadiusBack, wheelWidthBack, BACK_RIGHT);' + '\n' +
'' + '\n' +
'    // Sync keybord actions and physics and graphics' + '\n' +
'    function sync() {' + '\n' +
'' + '\n' +
'        var speed = vehicle.getCurrentSpeedKmHour();' + '\n' +
'' + '\n' +
'        breakingForce = 0;' + '\n' +
'        engineForce = 0;' + '\n' +
'' + '\n' +
'        if (VARS.actions.acceleration) {' + '\n' +
'            if (speed < -1)' + '\n' +
'                breakingForce = VARS.maxBreakingForce;' + '\n' +
'            else' + '\n' +
'                engineForce = VARS.maxEngineForce;' + '\n' +
'        }' + '\n' +
'        if (VARS.actions.braking) {' + '\n' +
'            if (speed > 1)' + '\n' +
'                breakingForce = VARS.maxBreakingForce;' + '\n' +
'            else' + '\n' +
'                engineForce = -VARS.maxEngineForce / 2;' + '\n' +
'        }' + '\n' +
'        if (VARS.actions.left) {' + '\n' +
'            if (vehicleSteering < VARS.steeringClamp)' + '\n' +
'                vehicleSteering += VARS.steeringIncrement;' + '\n' +
'        }' + '\n' +
'        else {' + '\n' +
'            if (VARS.actions.right) {' + '\n' +
'                if (vehicleSteering > -VARS.steeringClamp)' + '\n' +
'                    vehicleSteering -= VARS.steeringIncrement;' + '\n' +
'            }' + '\n' +
'            else {' + '\n' +
'                if (vehicleSteering < -VARS.steeringIncrement)' + '\n' +
'                    vehicleSteering += VARS.steeringIncrement;' + '\n' +
'                else {' + '\n' +
'                    if (vehicleSteering > VARS.steeringIncrement)' + '\n' +
'                        vehicleSteering -= VARS.steeringIncrement;' + '\n' +
'                    else {' + '\n' +
'                        vehicleSteering = 0;' + '\n' +
'                    }' + '\n' +
'                }' + '\n' +
'            }' + '\n' +
'        }' + '\n' +
'        ' + '\n' +
'        vehicle.applyEngineForce(engineForce, BACK_LEFT);' + '\n' +
'        vehicle.applyEngineForce(engineForce, BACK_RIGHT);' + '\n' +
'' + '\n' +
'        vehicle.setBrake(breakingForce / 2, FRONT_LEFT);' + '\n' +
'        vehicle.setBrake(breakingForce / 2, FRONT_RIGHT);' + '\n' +
'        vehicle.setBrake(breakingForce, BACK_LEFT);' + '\n' +
'        vehicle.setBrake(breakingForce, BACK_RIGHT);' + '\n' +
'' + '\n' +
'        vehicle.setSteeringValue(vehicleSteering, FRONT_LEFT);' + '\n' +
'        vehicle.setSteeringValue(vehicleSteering, FRONT_RIGHT);' + '\n' +
'' + '\n' +
'' + '\n' +
'        var tm, p, q, i;' + '\n' +
'        var n = vehicle.getNumWheels();' + '\n' +
'        for (i = 0; i < n; i++) {' + '\n' +
'            vehicle.updateWheelTransform(i, true);' + '\n' +
'            tm = vehicle.getWheelTransformWS(i);' + '\n' +
'            p = tm.getOrigin();' + '\n' +
'            q = tm.getRotation();' + '\n' +
'            wheelMeshes[i].position.set(p.x(), p.y(), p.z());' + '\n' +
'            wheelMeshes[i].quaternion.set(q.x(), q.y(), q.z(), q.w());' + '\n' +
'            wheelMeshes[i].scale.x = -1;' + '\n' +
'        }' + '\n' +
'' + '\n' +
'    }' + '\n' +
'' + '\n' +
'    VARS.syncVehicleCallback = sync;' + '\n' +
'}' + '\n' +
'' + '\n' +
'createVehicle(new v3d.Vector3(0, 1, 0), ZERO_QUATERNION);' + '\n' +
'')))(appInstance, v3d, VARS, PROC);


camera_moving_speed = 0.1;
registerEveryFrame(function() {
  if (game_started == true) {
    if (moving_side == 'left' && getDistanceBetweenObjects('Camera', 'camera_base_point') < 2) {
      camera_moving_speed = camera_moving_speed / 1.01;
      setObjTransform('Camera', 'position', camera_moving_speed, '', '', true);
      tweenCamera('', 'look_at_point', 0, function() {}, 0);
    } else if (moving_side == 'right' && getDistanceBetweenObjects('Camera', 'camera_base_point') < 2) {
      camera_moving_speed = camera_moving_speed / 1.01;
      setObjTransform('Camera', 'position', camera_moving_speed * -1, '', '', true);
      tweenCamera('', 'look_at_point', 0, function() {}, 0);
    } else if (moving_side == 'none') {

      animateParam(getObjTransform('Camera', 'position', 'x'), 0, 0.1, 'Linear', 'InOut', 0, false,
          function() {
        setObjTransform('Camera', 'position', _pGlob.animateParamUpdate, '', '', false);
      },
          function() {});


      animateParam(getObjTransform('Camera', 'position', 'y'), getObjTransform('camera_base_point', 'position', 'y'), 0.1, 'Linear', 'InOut', 0, false,
          function() {
        setObjTransform('Camera', 'position', '', _pGlob.animateParamUpdate, '', false);
      },
          function() {});


      animateParam(getObjTransform('Camera', 'position', 'z'), getObjTransform('camera_base_point', 'position', 'z'), 0.1, 'Linear', 'InOut', 0, false,
          function() {
        setObjTransform('Camera', 'position', '', '', _pGlob.animateParamUpdate, false);
      },
          function() {});

          tweenCamera('', 'look_at_point', 0.1, function() {}, 0);
      camera_moving_speed = 0.1;
    }
  }
});

if (featureAvailable('MOBILE') == true) {
  changeVis('tap_to_start', true);
} else {
  changeVis('click_to_start', true);
}
registerOnClick(['tap_to_start', 'click_to_start'], false, false, [0,1,2], function() {
  playSound(loadMedia_WebAudio('./sounds/engine_start.mp3'), false);
  playSound(sound_breaking_skid, true);
  registerSetTimeout(1, function() {
    playSound(sound_base_engine, true);
  });
  changeVis(['tap_to_start', 'click_to_start', 'logo', 'desktop_help', 'help', 'mobile_help'], false);
  game_started = true;
  changeVis(['start_counter', 'speedometer', 'speedometer_arrow', 'damage_map'], true);
  start_counter = 0;
  tweenCamera('camera_base_point', 'look_at_point', 3, function() {}, 0);
  registerSetTimeout(4, function() {
    race_restart();
  });
  change_track();
}, function() {});

eventHTMLElem('keydown', ['DOCUMENT'], false, function(event) {
  if (getEventProperty('code', event) == 'KeyH') {
    if (help_shown == false) {
      if (featureAvailable('MOBILE') == true) {
        changeVis('mobile_help', true);
      } else {
        changeVis('desktop_help', true);
      }
      help_shown = true;
    } else {
      changeVis(['desktop_help', 'mobile_help'], false);
      help_shown = false;
    }
  }
});

help_shown = false;
registerOnClick('help', false, false, [0,1,2], function() {
  if (help_shown == false) {
    if (featureAvailable('MOBILE') == true) {
      changeVis('mobile_help', true);
    } else {
      changeVis('desktop_help', true);
    }
    help_shown = true;
  } else {
    changeVis(['desktop_help', 'mobile_help'], false);
    help_shown = false;
  }
}, function() {});

onSimulationTick('BEFORE', function() {
  var VARS = Object.defineProperties({}, {
    "game_started": { get: function() { return game_started; }, set: function(val) { game_started = val; } },
    "sound_breaking_skid": { get: function() { return sound_breaking_skid; }, set: function(val) { sound_breaking_skid = val; } },
    "steeringIncrement_multiplier": { get: function() { return steeringIncrement_multiplier; }, set: function(val) { steeringIncrement_multiplier = val; } },
    "steeringIncrement": { get: function() { return steeringIncrement; }, set: function(val) { steeringIncrement = val; } },
    "actions": { get: function() { return actions; }, set: function(val) { actions = val; } },
    "camera_moving_speed": { get: function() { return camera_moving_speed; }, set: function(val) { camera_moving_speed = val; } },
    "help_shown": { get: function() { return help_shown; }, set: function(val) { help_shown = val; } },
    "sound_base_engine": { get: function() { return sound_base_engine; }, set: function(val) { sound_base_engine = val; } },
    "steeringClamp": { get: function() { return steeringClamp; }, set: function(val) { steeringClamp = val; } },
    "screen_ratio": { get: function() { return screen_ratio; }, set: function(val) { screen_ratio = val; } },
    "maxEngineForce": { get: function() { return maxEngineForce; }, set: function(val) { maxEngineForce = val; } },
    "maxBreakingForce": { get: function() { return maxBreakingForce; }, set: function(val) { maxBreakingForce = val; } },
    "input_range_start": { get: function() { return input_range_start; }, set: function(val) { input_range_start = val; } },
    "input_range_end": { get: function() { return input_range_end; }, set: function(val) { input_range_end = val; } },
    "result_range_start": { get: function() { return result_range_start; }, set: function(val) { result_range_start = val; } },
    "result_range_end": { get: function() { return result_range_end; }, set: function(val) { result_range_end = val; } },
    "input_value": { get: function() { return input_value; }, set: function(val) { input_value = val; } },
    "car_speed": { get: function() { return car_speed; }, set: function(val) { car_speed = val; } },
    "syncVehicleCallback": { get: function() { return syncVehicleCallback; }, set: function(val) { syncVehicleCallback = val; } },
    "moving_side": { get: function() { return moving_side; }, set: function(val) { moving_side = val; } },
    "race_started": { get: function() { return race_started; }, set: function(val) { race_started = val; } },
    "summ_damage": { get: function() { return summ_damage; }, set: function(val) { summ_damage = val; } },
    "start_counter": { get: function() { return start_counter; }, set: function(val) { start_counter = val; } },
    "dead_zone_start": { get: function() { return dead_zone_start; }, set: function(val) { dead_zone_start = val; } },
    "building_collisions": { get: function() { return building_collisions; }, set: function(val) { building_collisions = val; } },
    "repair_shop_start": { get: function() { return repair_shop_start; }, set: function(val) { repair_shop_start = val; } },
    "paint_shop_green_start": { get: function() { return paint_shop_green_start; }, set: function(val) { paint_shop_green_start = val; } },
    "buildings": { get: function() { return buildings; }, set: function(val) { buildings = val; } },
    "paint_shop_orange_start": { get: function() { return paint_shop_orange_start; }, set: function(val) { paint_shop_orange_start = val; } },
    "bl_j": { get: function() { return bl_j; }, set: function(val) { bl_j = val; } },
    "paint_shop_blue_start": { get: function() { return paint_shop_blue_start; }, set: function(val) { paint_shop_blue_start = val; } },
    "front_damaged": { get: function() { return front_damaged; }, set: function(val) { front_damaged = val; } },
    "front_right_damaged": { get: function() { return front_right_damaged; }, set: function(val) { front_right_damaged = val; } },
    "front_left_damaged": { get: function() { return front_left_damaged; }, set: function(val) { front_left_damaged = val; } },
    "rear_damaged": { get: function() { return rear_damaged; }, set: function(val) { rear_damaged = val; } },
    "rear_left_damaged": { get: function() { return rear_left_damaged; }, set: function(val) { rear_left_damaged = val; } },
    "rear_right_damaged": { get: function() { return rear_right_damaged; }, set: function(val) { rear_right_damaged = val; } },
    "barrel_hit_start": { get: function() { return barrel_hit_start; }, set: function(val) { barrel_hit_start = val; } },
    "static_props_collisions": { get: function() { return static_props_collisions; }, set: function(val) { static_props_collisions = val; } },
    "tyres": { get: function() { return tyres; }, set: function(val) { tyres = val; } },
    "furniture_hit_start": { get: function() { return furniture_hit_start; }, set: function(val) { furniture_hit_start = val; } },
    "cacti_hit_start": { get: function() { return cacti_hit_start; }, set: function(val) { cacti_hit_start = val; } },
    "traffic_cone_hit_start": { get: function() { return traffic_cone_hit_start; }, set: function(val) { traffic_cone_hit_start = val; } },
    "cacti_mesh": { get: function() { return cacti_mesh; }, set: function(val) { cacti_mesh = val; } },
    "barrels": { get: function() { return barrels; }, set: function(val) { barrels = val; } },
    "static_props": { get: function() { return static_props; }, set: function(val) { static_props = val; } },
    "pl_i": { get: function() { return pl_i; }, set: function(val) { pl_i = val; } },
    "furniture": { get: function() { return furniture; }, set: function(val) { furniture = val; } },
    "cacti_capsule": { get: function() { return cacti_capsule; }, set: function(val) { cacti_capsule = val; } },
    "traffic_cones": { get: function() { return traffic_cones; }, set: function(val) { traffic_cones = val; } },
    "j": { get: function() { return j; }, set: function(val) { j = val; } },
    "sound_glass_crash": { get: function() { return sound_glass_crash; }, set: function(val) { sound_glass_crash = val; } },
    "list_of_speed_current": { get: function() { return list_of_speed_current; }, set: function(val) { list_of_speed_current = val; } },
    "respawn_in_action": { get: function() { return respawn_in_action; }, set: function(val) { respawn_in_action = val; } },
    "for_damage_list": { get: function() { return for_damage_list; }, set: function(val) { for_damage_list = val; } },
    "front_damage_start": { get: function() { return front_damage_start; }, set: function(val) { front_damage_start = val; } },
    "respawn_set": { get: function() { return respawn_set; }, set: function(val) { respawn_set = val; } },
    "car_body_hit_start": { get: function() { return car_body_hit_start; }, set: function(val) { car_body_hit_start = val; } },
    "sound_front_crash": { get: function() { return sound_front_crash; }, set: function(val) { sound_front_crash = val; } },
    "list_of_speed": { get: function() { return list_of_speed; }, set: function(val) { list_of_speed = val; } },
    "result_range": { get: function() { return result_range; }, set: function(val) { result_range = val; } },
    "output_value": { get: function() { return output_value; }, set: function(val) { output_value = val; } },
    "front_right_damage_start": { get: function() { return front_right_damage_start; }, set: function(val) { front_right_damage_start = val; } },
    "front_left_damage_start": { get: function() { return front_left_damage_start; }, set: function(val) { front_left_damage_start = val; } },
    "car_down": { get: function() { return car_down; }, set: function(val) { car_down = val; } },
    "car_drop_start": { get: function() { return car_drop_start; }, set: function(val) { car_drop_start = val; } },
    "rear_damage_start": { get: function() { return rear_damage_start; }, set: function(val) { rear_damage_start = val; } },
    "rear_right_damage_start": { get: function() { return rear_right_damage_start; }, set: function(val) { rear_right_damage_start = val; } },
    "rear_left_damge_start": { get: function() { return rear_left_damge_start; }, set: function(val) { rear_left_damge_start = val; } },
    "sound_right_crash": { get: function() { return sound_right_crash; }, set: function(val) { sound_right_crash = val; } },
    "car_stopped": { get: function() { return car_stopped; }, set: function(val) { car_stopped = val; } },
    "sound_left_crash": { get: function() { return sound_left_crash; }, set: function(val) { sound_left_crash = val; } },
    "list_of_height": { get: function() { return list_of_height; }, set: function(val) { list_of_height = val; } },
    "car_x_rotation": { get: function() { return car_x_rotation; }, set: function(val) { car_x_rotation = val; } },
    "car_falling": { get: function() { return car_falling; }, set: function(val) { car_falling = val; } },
    "current_track": { get: function() { return current_track; }, set: function(val) { current_track = val; } },
    "car_y_rotation": { get: function() { return car_y_rotation; }, set: function(val) { car_y_rotation = val; } },
    "list_of_speed_i": { get: function() { return list_of_speed_i; }, set: function(val) { list_of_speed_i = val; } },
    "list_of_height_current": { get: function() { return list_of_height_current; }, set: function(val) { list_of_height_current = val; } },
    "car_height": { get: function() { return car_height; }, set: function(val) { car_height = val; } },
    "list_of_height_i": { get: function() { return list_of_height_i; }, set: function(val) { list_of_height_i = val; } },
    "playground_props": { get: function() { return playground_props; }, set: function(val) { playground_props = val; } },
    "gates": { get: function() { return gates; }, set: function(val) { gates = val; } },
    "gates_hit_start": { get: function() { return gates_hit_start; }, set: function(val) { gates_hit_start = val; } },
    "gt_i": { get: function() { return gt_i; }, set: function(val) { gt_i = val; } },
    "next_checkpoint": { get: function() { return next_checkpoint; }, set: function(val) { next_checkpoint = val; } },
    "current_checkpoint": { get: function() { return current_checkpoint; }, set: function(val) { current_checkpoint = val; } },
    "checkpoint_touch_start": { get: function() { return checkpoint_touch_start; }, set: function(val) { checkpoint_touch_start = val; } },
    "checkpoint_seconds": { get: function() { return checkpoint_seconds; }, set: function(val) { checkpoint_seconds = val; } },
    "checkpoint_minutes": { get: function() { return checkpoint_minutes; }, set: function(val) { checkpoint_minutes = val; } },
    "press_r": { get: function() { return press_r; }, set: function(val) { press_r = val; } },
    "no_count": { get: function() { return no_count; }, set: function(val) { no_count = val; } },
    "checkpoint_total_time": { get: function() { return checkpoint_total_time; }, set: function(val) { checkpoint_total_time = val; } },
    "touch_1_busy": { get: function() { return touch_1_busy; }, set: function(val) { touch_1_busy = val; } },
    "mono_rotate_on": { get: function() { return mono_rotate_on; }, set: function(val) { mono_rotate_on = val; } },
    "maxBreakingForce_multiplier": { get: function() { return maxBreakingForce_multiplier; }, set: function(val) { maxBreakingForce_multiplier = val; } },
    "touch_1_base_x": { get: function() { return touch_1_base_x; }, set: function(val) { touch_1_base_x = val; } },
    "touch_1_x_length": { get: function() { return touch_1_x_length; }, set: function(val) { touch_1_x_length = val; } },
    "touch_2_base_x": { get: function() { return touch_2_base_x; }, set: function(val) { touch_2_base_x = val; } },
    "touch_2_x_length": { get: function() { return touch_2_x_length; }, set: function(val) { touch_2_x_length = val; } },
    "touch_1_base_y": { get: function() { return touch_1_base_y; }, set: function(val) { touch_1_base_y = val; } },
    "touch_1_y_length": { get: function() { return touch_1_y_length; }, set: function(val) { touch_1_y_length = val; } },
    "track_1": { get: function() { return track_1; }, set: function(val) { track_1 = val; } },
    "track_2": { get: function() { return track_2; }, set: function(val) { track_2 = val; } },
    "random_number": { get: function() { return random_number; }, set: function(val) { random_number = val; } },
    "track_3": { get: function() { return track_3; }, set: function(val) { track_3 = val; } },
    "current_track_number": { get: function() { return current_track_number; }, set: function(val) { current_track_number = val; } },
});

  Function('app', 'v3d', 'VARS', 'PROC', 'VARS.syncVehicleCallback();')(appInstance, v3d, VARS, PROC);

});

eventHTMLElem('resize', ['WINDOW'], false, function(event) {
  interface_recalc();
  rotate_your_device_message();
});

createPhysicsBody('STATIC', 'ground', 'MESH', 0);
createPhysicsBody('STATIC', 'cliffs_collision', 'MESH', 0);

createPhysicsBody('GHOST', 'dead_zone', 'BOX', 0);

dead_zone_start = false;

detectCollision('car_body', 'dead_zone', function() {
  if (dead_zone_start == false) {
    respawn();
  }
  dead_zone_start = true;
}, function() {
  dead_zone_start = false;
});

volume(loadMedia_WebAudio('./sounds/spray.mp3'), 0.6);
volume(loadMedia_WebAudio('./sounds/car_fixing.mp3'), 0.6);

building_collisions = [];

repair_shop_start = false;

paint_shop_green_start = false;
paint_shop_orange_start = false;
paint_shop_blue_start = false;

createPhysicsBody('GHOST', 'paintshop_blue_activator', 'BOX', 0);
createPhysicsBody('GHOST', 'paintshop_orange_activator', 'BOX', 0);
createPhysicsBody('GHOST', 'paintshop_green_activator', 'BOX', 0);
createPhysicsBody('GHOST', 'repairshop_activator', 'BOX', 0);

buildings = getObjectsFrom(['GROUP', 'buildings'], 'MESH');
for (var bl_j_index in buildings) {
  bl_j = buildings[bl_j_index];
  if (bl_j.indexOf('collision') != -1) {
    createPhysicsBody('STATIC', bl_j, 'MESH', 0);
    building_collisions.push(bl_j);
  }
}

detectCollision('car_body', 'paintshop_green_activator', function() {
  if (paint_shop_green_start == false) {
    replaceTexture('car_shader', 'diffuse', './diffuse_green.jpg', function() {});
    paint_shop_green_start = true;
    playSound(loadMedia_WebAudio('./sounds/spray.mp3'), false);
  }
}, function() {
  paint_shop_green_start = false;
});

detectCollision('car_body', 'paintshop_blue_activator', function() {
  if (paint_shop_blue_start == false) {
    replaceTexture('car_shader', 'diffuse', './diffuse_blue.jpg', function() {});
    paint_shop_blue_start = true;
    playSound(loadMedia_WebAudio('./sounds/spray.mp3'), false);
  }
}, function() {
  paint_shop_blue_start = false;
});

detectCollision('car_body', 'paintshop_orange_activator', function() {
  if (paint_shop_orange_start == false) {
    replaceTexture('car_shader', 'diffuse', './diffuse_orange.jpg', function() {});
    paint_shop_orange_start = true;
    playSound(loadMedia_WebAudio('./sounds/spray.mp3'), false);
  }
}, function() {
  paint_shop_orange_start = false;
});

detectCollision('car_body', 'repairshop_activator', function() {
  if (repair_shop_start == false) {
    car_repair();
  }
  repair_shop_start = true;
}, function() {
  repair_shop_start = false;
});

barrel_hit_start = false;
barrels = getObjectsFrom(['GROUP', 'barrels'], 'MESH');
for (var pl_i_index in barrels) {
  pl_i = barrels[pl_i_index];
  makeParent(pl_i, '<none>');
  createPhysicsBody('DYNAMIC', pl_i, 'CYLINDER', 5);
  physicsBodyApplyParam('ANGULAR_DAMPING', pl_i, 0.7);
  setBodyState('SLEEP', pl_i);
}
removeObject(getObjectsFrom(['GROUP', 'barrels'], 'EMPTY'));

static_props_collisions = [];
static_props = getObjectsFrom(['GROUP', 'static_props'], 'MESH');
for (var j_index in static_props) {
  j = static_props[j_index];
  if (j.indexOf('collision') != -1) {
    createPhysicsBody('STATIC', j, 'MESH', 0);
    static_props_collisions.push(j);
  }
}

tyres = getObjectsFrom(['GROUP', 'tyres'], 'MESH');
for (var pl_i_index2 in tyres) {
  pl_i = tyres[pl_i_index2];
  makeParent(pl_i, '<none>');
  createPhysicsBody('DYNAMIC', pl_i, 'CYLINDER', 4);
  physicsBodyApplyParam('ANGULAR_DAMPING', pl_i, 0.5);
  setBodyState('SLEEP', pl_i);
}
removeObject(getObjectsFrom(['GROUP', 'tyres'], 'EMPTY'));

furniture_hit_start = false;
furniture = getObjectsFrom(['GROUP', 'furniture'], 'MESH');
for (var pl_i_index3 in furniture) {
  pl_i = furniture[pl_i_index3];
  makeParent(pl_i, '<none>');
  createPhysicsBody('DYNAMIC', pl_i, 'BOX', 3);
  physicsBodyApplyParam('FRICTION', pl_i, 0.8);
  setBodyState('SLEEP', pl_i);
}
removeObject(getObjectsFrom(['GROUP', 'furniture'], 'EMPTY'));

cacti_hit_start = false;
cacti_capsule = getObjectsFrom(['GROUP', 'cacti_capsule'], 'MESH');
for (var pl_i_index4 in cacti_capsule) {
  pl_i = cacti_capsule[pl_i_index4];
  makeParent(pl_i, '<none>');
  createPhysicsBody('DYNAMIC', pl_i, 'CAPSULE', 3);
  physicsBodyApplyParam('ANGULAR_DAMPING', pl_i, 0.9);
  setBodyState('SLEEP', pl_i);
}
removeObject(getObjectsFrom(['GROUP', 'cacti_capsule'], 'EMPTY'));

traffic_cone_hit_start = false;
traffic_cones = getObjectsFrom(['GROUP', 'traffic_cones'], 'MESH');
for (var pl_i_index5 in traffic_cones) {
  pl_i = traffic_cones[pl_i_index5];
  makeParent(pl_i, '<none>');
  createPhysicsBody('DYNAMIC', pl_i, 'CONE', 0.5);
  physicsBodyApplyParam('ANGULAR_DAMPING', pl_i, 0.7);
  physicsBodyApplyParam('FRICTION', pl_i, 0.9);
  setBodyState('SLEEP', pl_i);
}
removeObject(getObjectsFrom(['GROUP', 'traffic_cones'], 'EMPTY'));

cacti_mesh = getObjectsFrom(['GROUP', 'cacti_mesh'], 'MESH');
for (var pl_i_index6 in cacti_mesh) {
  pl_i = cacti_mesh[pl_i_index6];
  makeParent(pl_i, '<none>');
  createPhysicsBody('DYNAMIC', pl_i, 'MESH', 1);
  physicsBodyApplyParam('ANGULAR_DAMPING', pl_i, 0.9);
  setBodyState('SLEEP', pl_i);
}
removeObject(getObjectsFrom(['GROUP', 'cacti_mesh'], 'EMPTY'));

detectCollision('car_body', barrels, function() {
  if (barrel_hit_start == false) {
    volume(loadMedia_WebAudio('./sounds/barrel_hit_1.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    volume(loadMedia_WebAudio('./sounds/barrel_hit_2.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    volume(loadMedia_WebAudio('./sounds/barrel_hit_3.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    if (!isSoundPlaying(loadMedia_WebAudio('./sounds/barrel_hit_1.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/barrel_hit_1.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/barrel_hit_2.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/barrel_hit_2.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/barrel_hit_3.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/barrel_hit_3.mp3'), false);
    }
  }
  barrel_hit_start = true;
}, function() {
  barrel_hit_start = false;
});

detectCollision('car_body', [cacti_capsule, cacti_mesh], function() {
  if (cacti_hit_start == false) {
    volume(loadMedia_WebAudio('./sounds/cacti_hit_1.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    volume(loadMedia_WebAudio('./sounds/cacti_hit_2.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    volume(loadMedia_WebAudio('./sounds/cacti_hit_3.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    if (!isSoundPlaying(loadMedia_WebAudio('./sounds/cacti_hit_1.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/cacti_hit_1.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/cacti_hit_2.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/cacti_hit_2.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/cacti_hit_3.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/cacti_hit_3.mp3'), false);
    }
  }
  cacti_hit_start = true;
}, function() {
  cacti_hit_start = false;
});

detectCollision('car_body', furniture, function() {
  if (furniture_hit_start == false) {
    volume(loadMedia_WebAudio('./sounds/furniture_hit_1.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    volume(loadMedia_WebAudio('./sounds/furniture_hit_2.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    volume(loadMedia_WebAudio('./sounds/furniture_hit_3.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    if (!isSoundPlaying(loadMedia_WebAudio('./sounds/furniture_hit_1.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/furniture_hit_1.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/furniture_hit_2.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/furniture_hit_2.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/furniture_hit_3.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/furniture_hit_3.mp3'), false);
    }
  }
  furniture_hit_start = true;
}, function() {
  furniture_hit_start = false;
});

detectCollision('car_body', traffic_cones, function() {
  if (traffic_cone_hit_start == false) {
    volume(loadMedia_WebAudio('./sounds/traffic_cone_hit_1.mp3'), map_range(0, 60, 0.1, 0.6, car_speed));
    volume(loadMedia_WebAudio('./sounds/traffic_cone_hit_2.mp3'), map_range(0, 60, 0.1, 0.6, car_speed));
    volume(loadMedia_WebAudio('./sounds/traffic_cone_hit_3.mp3'), map_range(0, 60, 0.1, 0.6, car_speed));
    if (!isSoundPlaying(loadMedia_WebAudio('./sounds/traffic_cone_hit_1.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/traffic_cone_hit_1.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/traffic_cone_hit_2.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/traffic_cone_hit_2.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/traffic_cone_hit_3.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/traffic_cone_hit_3.mp3'), false);
    }
  }
  traffic_cone_hit_start = true;
}, function() {
  traffic_cone_hit_start = false;
});

sound_glass_crash = loadMedia_WebAudio('./sounds/glass_crash.mp3');
sound_front_crash = loadMedia_WebAudio('./sounds/front_rear_crash.mp3');
sound_right_crash = loadMedia_WebAudio('./sounds/right_crash.mp3');
sound_left_crash = loadMedia_WebAudio('./sounds/left_crash.mp3');
volume(sound_front_crash, 0.01);
volume(sound_right_crash, 0.01);
volume(sound_left_crash, 0.01);

registerEveryFrame(function() {
  if (list_of_speed_i - car_speed > 5 && (typeof actions == 'object' && actions.hasOwnProperty('braking')) == true) {
    volume(sound_breaking_skid, map_range(0, 80, 0.2, 1, car_speed));
  } else {
    volume(sound_breaking_skid, 0);
  }
});

list_of_speed_current = 0;
list_of_speed = [];
car_stopped = false;
list_of_height = [];
car_falling = false;
list_of_height_current = 0;
registerEveryFrame(function() {
  car_speed = Math.round(getVectorValue(physicsBodyGetParam('LINEAR_VELOCITY', 'car_body'), 'LENGTH') * 2.4);
  if (list_of_speed_current <= 10) {
    list_of_speed[list_of_speed_current] = car_speed;
    list_of_speed_current = list_of_speed_current + 1;
    for (var list_of_speed_i_index in list_of_speed) {
      list_of_speed_i = list_of_speed[list_of_speed_i_index];
      if (list_of_speed_i - car_speed > 5) {
        car_stopped = true;
      } else {
        if (car_speed > 10) {
          car_stopped = false;
        }
      }
    }
  } else {
    list_of_speed_current = 0;
    list_of_speed[list_of_speed_current] = car_speed;
  }
  car_height = physicsBodyGetParam('POSITION', 'car_body')[2];
  if (list_of_height_current <= 10) {
    list_of_height[list_of_height_current] = car_height;
    list_of_height_current = list_of_height_current + 1;
    for (var list_of_height_i_index in list_of_height) {
      list_of_height_i = list_of_height[list_of_height_i_index];
      if (list_of_height_i - car_height > 0.5) {
        car_falling = true;
        console.log('Car Falling');
      } else {
      }
    }
  } else {
    list_of_height_current = 0;
    list_of_height[list_of_height_current] = car_height;
  }
});

respawn_in_action = false;
volume(loadMedia_WebAudio('./sounds/respawn_transition.mp3'), 0.3);

summ_damage = 0;
front_damaged = 0;
front_right_damaged = 0;
front_left_damaged = 0;
rear_damaged = 0;
rear_left_damaged = 0;
rear_right_damaged = 0;

for_damage_list = [static_props_collisions, 'cliffs_collision', building_collisions, 'ground'];

createPhysicsBody('GHOST', 'front_right_damage_collider', 'BOX', 0);
createPhysicsBody('GHOST', 'front_left_damage_collider', 'BOX', 0);
createPhysicsBody('GHOST', 'front_damage_collider', 'BOX', 0);
createPhysicsBody('GHOST', 'rear_damage_collider', 'BOX', 0);
createPhysicsBody('GHOST', 'rear_left_damage_collider', 'BOX', 0);
createPhysicsBody('GHOST', 'rear_right_damage_collider', 'BOX', 0);

front_damage_start = false;
front_right_damage_start = false;
front_left_damage_start = false;

detectCollision('front_damage_collider', for_damage_list, function() {
  if (front_damage_start == false) {
    console.log('front_collision');
    volume(sound_front_crash, map_range(0, 100, 0.01, 0.7, list_of_speed[5]));
    volume(sound_glass_crash, map_range(0, 100, -0.5, 1, list_of_speed[5]));
    if (car_stopped == true) {
      playSound(sound_front_crash, false);
      if (isSoundPlaying(sound_glass_crash) == false) {
        playSound(sound_glass_crash, false);
      }
      front_damaged = front_damaged + map_range(5, 100, 0, 1, list_of_speed[5]);
      if (front_damaged > 3) {
        front_damaged = 3;
      }
      setMorphFactor('car_body', 'front_damage', front_damaged);
      engine_force_recalc();
      damage_map_update();
    }
  }
  front_damage_start = true;
}, function() {
  front_damage_start = false;
});

detectCollision('front_right_damage_collider', for_damage_list, function() {
  if (front_right_damage_start == false) {
    console.log('front_right_collision');
    volume(sound_right_crash, map_range(0, 100, 0.01, 0.7, list_of_speed[5]));
    volume(sound_glass_crash, map_range(0, 100, -0.5, 1, list_of_speed[5]));
    if (car_stopped == true) {
      playSound(sound_right_crash, false);
      if (isSoundPlaying(sound_glass_crash) == false) {
        playSound(sound_glass_crash, false);
      }
      front_right_damaged = front_right_damaged + map_range(5, 100, 0, 1, list_of_speed[5]);
      if (front_right_damaged > 3) {
        front_right_damaged = 3;
      }
      setMorphFactor('car_body', 'front_right_damage', front_right_damaged);
      setMorphFactor('wheel_front_right', 'damage', front_right_damaged);
      engine_force_recalc();
      damage_map_update();
    }
  }
  front_right_damage_start = true;
}, function() {
  front_right_damage_start = false;
});

detectCollision('front_left_damage_collider', for_damage_list, function() {
  if (front_left_damage_start == false) {
    console.log('front_left_collision');
    volume(sound_left_crash, map_range(0, 100, 0.01, 0.7, list_of_speed[5]));
    volume(sound_glass_crash, map_range(0, 100, -0.5, 1, list_of_speed[5]));
    if (car_stopped == true) {
      playSound(sound_left_crash, false);
      if (isSoundPlaying(sound_glass_crash) == false) {
        playSound(sound_glass_crash, false);
      }
      front_left_damaged = front_left_damaged + map_range(5, 100, 0, 1, list_of_speed[5]);
      if (front_left_damaged > 3) {
        front_left_damaged = 3;
      }
      setMorphFactor('car_body', 'front_left_damage', front_left_damaged);
      setMorphFactor('wheel_front_left', 'damage', front_left_damaged);
      engine_force_recalc();
      damage_map_update();
    }
  }
  front_left_damage_start = true;
}, function() {
  front_left_damage_start = false;
});

createPhysicsBody('GHOST', 'car_drop_collision', 'BOX', 0);

respawn_set = false;
car_down = false;
registerInterval(1, function() {
  car_x_rotation = getObjTransform('car_body', 'rotation', 'x');
  car_y_rotation = getObjTransform('car_body', 'rotation', 'y');
  if (car_y_rotation > 85 || car_y_rotation < -85 || car_x_rotation > 85 || car_x_rotation < -85) {
    car_down = true;
    if (respawn_set == false) {
      respawn_set = true;
      registerSetTimer('respawn_after', 1, function() {
        respawn_set = false;
        car_down = false;
        respawn();
      }, 1);
    }
  } else {
    registerRemoveTimer('respawn_after');
    respawn_set = false;
    car_down = false;
  }
});

volume(loadMedia_WebAudio('./sounds/car_fall.mp3'), 0.1);
car_drop_start = true;

detectCollision('car_drop_collision', 'ground', function() {
  if (car_drop_start == false) {
    car_drop_start = true;
    if (car_falling == true) {
      volume(loadMedia_WebAudio('./sounds/car_fall.mp3'), map_range(0.5, 4, 0.1, 1, list_of_height[1]));
      playSound(loadMedia_WebAudio('./sounds/car_fall.mp3'), false);
      console.log(list_of_height[1]);
      car_falling = false;
    }
  }
}, function() {
  car_drop_start = false;
});

registerEveryFrame(function() {
  setMaterialValue('arrow', 'rotation', map_range(0, 100, 0, 5.3, car_speed));
  setPlaybackRate(sound_base_engine, map_range(0, 100, 1, 3, car_speed));
  volume(sound_base_engine, map_range(0, 100, 0.5, 1, car_speed));
});

car_body_hit_start = false;

detectCollision('rear_damage_collider', for_damage_list, function() {
  if (rear_damage_start == false) {
    volume(sound_front_crash, map_range(0, 100, 0.01, 0.7, list_of_speed[5]));
    volume(sound_glass_crash, map_range(0, 100, -0.5, 1, list_of_speed[5]));
    if (car_stopped == true) {
      playSound(sound_front_crash, false);
      if (isSoundPlaying(sound_glass_crash) == false) {
        playSound(sound_glass_crash, false);
      }
      rear_damaged = rear_damaged + map_range(5, 100, 0, 1, list_of_speed[5]);
      if (rear_damaged > 3) {
        rear_damaged = 3;
      }
      setMorphFactor('car_body', 'rear_damage', rear_damaged);
      engine_force_recalc();
      damage_map_update();
    }
  }
  rear_damage_start = true;
}, function() {
  rear_damage_start = false;
});

detectCollision('rear_right_damage_collider', for_damage_list, function() {
  if (rear_right_damage_start == false) {
    volume(sound_right_crash, map_range(0, 100, 0.01, 0.7, list_of_speed[5]));
    volume(sound_glass_crash, map_range(0, 100, -0.5, 1, list_of_speed[5]));
    if (car_stopped == true) {
      playSound(sound_right_crash, false);
      if (isSoundPlaying(sound_glass_crash) == false) {
        playSound(sound_glass_crash, false);
      }
      rear_right_damaged = rear_right_damaged + map_range(5, 100, 0, 1, list_of_speed[5]);
      if (rear_right_damaged > 3) {
        rear_right_damaged = 3;
      }
      setMorphFactor('car_body', 'rear_right_damage', rear_right_damaged);
      setMorphFactor('wheel_rear_right', 'damage', rear_right_damaged);
      engine_force_recalc();
      damage_map_update();
    }
  }
  rear_right_damage_start = true;
}, function() {
  rear_right_damage_start = false;
});

volume(loadMedia_HTML5('./sounds/car_body_hit_1.mp3'), 0.1);
volume(loadMedia_HTML5('./sounds/car_body_hit_2.mp3'), 0.1);
volume(loadMedia_HTML5('./sounds/car_body_hit_3.mp3'), 0.1);
volume(loadMedia_HTML5('./sounds/car_body_hit_4.mp3'), 0.1);

detectCollision('rear_left_damage_collider', for_damage_list, function() {
  if (rear_left_damge_start == false) {
    volume(sound_left_crash, map_range(0, 100, 0.01, 0.7, list_of_speed[5]));
    volume(sound_glass_crash, map_range(0, 100, -0.5, 1, list_of_speed[5]));
    if (car_stopped == true) {
      playSound(sound_left_crash, false);
      if (isSoundPlaying(sound_glass_crash) == false) {
        playSound(sound_glass_crash, false);
      }
      rear_left_damaged = rear_left_damaged + map_range(5, 100, 0, 1, list_of_speed[5]);
      if (rear_left_damaged > 3) {
        rear_left_damaged = 3;
      }
      setMorphFactor('car_body', 'rear_left_damage', 1);
      setMorphFactor('wheel_rear_left', 'damage', 1);
      engine_force_recalc();
      damage_map_update();
    }
  }
  rear_left_damge_start = true;
}, function() {
  rear_left_damge_start = false;
});

detectCollision('car_body', 'ground', function() {
  if (car_body_hit_start == false) {
    car_body_hit_start = true;
    volume(loadMedia_HTML5('./sounds/car_body_hit_1.mp3'), map_range(0, 100, 0.01, 0.7, list_of_speed[5]));
    volume(loadMedia_HTML5('./sounds/car_body_hit_2.mp3'), map_range(0, 100, 0.01, 0.7, list_of_speed[5]));
    volume(loadMedia_HTML5('./sounds/car_body_hit_3.mp3'), map_range(0, 100, 0.01, 0.7, list_of_speed[5]));
    volume(loadMedia_HTML5('./sounds/car_body_hit_4.mp3'), map_range(0, 100, 0.01, 0.7, list_of_speed[5]));
    if (!isSoundPlaying(loadMedia_WebAudio('./sounds/car_body_hit_1.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/car_body_hit_1.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/car_body_hit_2.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/car_body_hit_2.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/car_body_hit_3.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/car_body_hit_3.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/car_body_hit_4.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/car_body_hit_4.mp3'), false);
    }
    console.log(car_speed);
  }
}, function() {
  car_body_hit_start = false;
});

playground_props = getObjectsFrom(['GROUP', 'playground'], 'MESH');
for (var pl_i_index7 in playground_props) {
  pl_i = playground_props[pl_i_index7];
  makeParent(pl_i, '<none>');
}
removeObject(getObjectsFrom(['GROUP', 'playground'], 'EMPTY'));

createPhysicsBody('STATIC', 'Instance_tree_with_a_tyre_tree_with_a_tyre', 'MESH', 0);
createPhysicsBody('DYNAMIC', ['Instance_tree_with_a_tyre_rope_on_a_tree_1', 'Instance_tree_with_a_tyre_rope_on_a_tree_2', 'Instance_tree_with_a_tyre_tyre_on_a_tree'], 'MESH', 5);
addPhysicsConstraint('Instance_tree_with_a_tyre_rope_on_a_tree_1', 'Instance_tree_with_a_tyre_tree_with_a_tyre', 'BALL', getObjTransform('Instance_tree_with_a_tyre_tree_with_a_tyre_axis_1', 'position', 'xyz'), [0, 0, 0], [0, 0, 0], [0, 0, 0]);
addPhysicsConstraint('Instance_tree_with_a_tyre_rope_on_a_tree_2', 'Instance_tree_with_a_tyre_rope_on_a_tree_1', 'BALL', getObjTransform('Instance_tree_with_a_tyre_tree_with_a_tyre_axis_2', 'position', 'xyz'), [0, 0, 0], [0, 0, 0], [0, 0, 0]);
addPhysicsConstraint('Instance_tree_with_a_tyre_tyre_on_a_tree', 'Instance_tree_with_a_tyre_rope_on_a_tree_2', 'BALL', getObjTransform('Instance_tree_with_a_tyre_tree_with_a_tyre_axis_3', 'position', 'xyz'), [0, 0, 0], [0, 0, 0], [0, 0, 0]);
physicsBodyApplyParam('ANGULAR_DAMPING', ['Instance_tree_with_a_tyre_rope_on_a_tree_1', 'Instance_tree_with_a_tyre_rope_on_a_tree_2', 'Instance_tree_with_a_tyre_tyre_on_a_tree'], 0.5);

createPhysicsBody('STATIC', ['Instance_swing.001_swing_static_part', 'Instance_swing_swing_static_part'], 'MESH', 0);
createPhysicsBody('DYNAMIC', ['Instance_swing.001_swing_dynamic_part', 'Instance_swing_swing_dynamic_part'], 'MESH', 5);
addPhysicsConstraint('Instance_swing.001_swing_dynamic_part', 'Instance_swing.001_swing_static_part', 'HINGE', getObjTransform('Instance_swing.001_swing_rotation_part', 'position', 'xyz'), getObjDirection('Instance_swing.001_swing_rotation_part', 'XYZ'), [0, 0, 0], [0, 0, 0]);
addPhysicsConstraint('Instance_swing_swing_dynamic_part', 'Instance_swing_swing_static_part', 'HINGE', getObjTransform('Instance_swing_swing_rotation_part', 'position', 'xyz'), getObjDirection('Instance_swing_swing_rotation_part', 'XYZ'), [0, 0, 0], [0, 0, 0]);
physicsBodyApplyParam('ANGULAR_DAMPING', ['Instance_swing.001_swing_dynamic_part', 'Instance_swing_swing_dynamic_part'], 0.9);

createPhysicsBody('STATIC', 'Instance_rocker_rocker_static_part', 'MESH', 0);
createPhysicsBody('DYNAMIC', 'Instance_rocker_rocker_dynamic_part', 'MESH', 5);
addPhysicsConstraint('Instance_rocker_rocker_dynamic_part', 'Instance_rocker_rocker_static_part', 'HINGE', getObjTransform('Instance_rocker_rocker_axis', 'position', 'xyz'), getObjDirection('Instance_rocker_rocker_axis', 'XYZ'), [0, 0, 0], [0, 0, 0]);

createPhysicsBody('DYNAMIC', 'Instance_carousel_carousel', 'CYLINDER', 5);
physicsBodyApplyParam('LINEAR_FACTOR', 'Instance_carousel_carousel', createVector(0, 0, 0));
physicsBodyApplyParam('ANGULAR_FACTOR', 'Instance_carousel_carousel', createVector(0, 0, 1));
physicsBodyApplyParam('ANGULAR_DAMPING', 'Instance_carousel_carousel', 0.2);

gates = getObjectsFrom(['GROUP', 'gates'], 'MESH');
for (var gt_i_index in gates) {
  gt_i = gates[gt_i_index];
  makeParent(gt_i, '<none>');
}
removeObject(getObjectsFrom(['GROUP', 'gates'], 'EMPTY'));

createPhysicsBody('STATIC', ['Instance_gates_gates_pillar', 'Instance_gates.001_gates_pillar'], 'MESH', 0);

createPhysicsBody('DYNAMIC', ['Instance_gates_gate_left', 'Instance_gates.001_gate_left'], 'MESH', 1);

gates_hit_start = false;

createPhysicsBody('DYNAMIC', ['Instance_gates_gate_right', 'Instance_gates.001_gate_right', null], 'MESH', 1);

detectCollision('car_body', ['Instance_gates_gate_left', 'Instance_gates.001_gate_left', 'Instance_gates_gate_right', 'Instance_gates.001_gate_right'], function() {
  if (gates_hit_start == false) {
    volume(loadMedia_WebAudio('./sounds/furniture_hit_1.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    volume(loadMedia_WebAudio('./sounds/furniture_hit_2.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    volume(loadMedia_WebAudio('./sounds/furniture_hit_3.mp3'), map_range(0, 60, 0.1, 1, car_speed));
    if (!isSoundPlaying(loadMedia_WebAudio('./sounds/furniture_hit_1.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/furniture_hit_1.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/furniture_hit_2.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/furniture_hit_2.mp3'), false);
    } else if (!isSoundPlaying(loadMedia_WebAudio('./sounds/furniture_hit_3.mp3'))) {
      playSound(loadMedia_WebAudio('./sounds/furniture_hit_3.mp3'), false);
    }
  }
  gates_hit_start = true;
}, function() {
  gates_hit_start = false;
});

addPhysicsConstraint('Instance_gates_gate_left', 'Instance_gates_gates_pillar', 'HINGE', getObjTransform('Instance_gates_gates_left_axis', 'position', 'xyz'), getObjDirection('Instance_gates_gates_left_axis', 'XYZ'), [0, 0, 0], [0, 0, 0]);
addPhysicsConstraint('Instance_gates.001_gate_left', 'Instance_gates.001_gates_pillar', 'HINGE', getObjTransform('Instance_gates.001_gates_left_axis', 'position', 'xyz'), getObjDirection('Instance_gates.001_gates_left_axis', 'XYZ'), [0, 0, 0], [0, 0, 0]);

addPhysicsConstraint('Instance_gates_gate_right', 'Instance_gates_gates_pillar', 'HINGE', getObjTransform('Instance_gates_gates_right_axis', 'position', 'xyz'), getObjDirection('Instance_gates_gates_right_axis', 'XYZ'), [0, 0, 0], [0, 0, 0]);
addPhysicsConstraint('Instance_gates.001_gate_right', 'Instance_gates.001_gates_pillar', 'HINGE', getObjTransform('Instance_gates.001_gates_right_axis', 'position', 'xyz'), getObjDirection('Instance_gates.001_gates_right_axis', 'XYZ'), [0, 0, 0], [0, 0, 0]);

physicsBodyApplyParam('ANGULAR_DAMPING', ['Instance_gates_gate_left', 'Instance_gates.001_gate_left', 'Instance_gates_gate_right', 'Instance_gates.001_gate_right'], 0.5);

volume(loadMedia_WebAudio('./sounds/race_begin.mp3'), 1);
volume(loadMedia_WebAudio('./sounds/checkpoint.mp3'), 1);
volume(loadMedia_WebAudio('./sounds/you_finished.mp3'), 1);

createPhysicsBody('GHOST', 'checkpoint', 'BOX', 0);
race_started = false;
checkpoint_seconds = 0;
checkpoint_minutes = 0;
press_r = false;
no_count = false;

registerEveryFrame(function() {
  if (race_started == true) {
    setMaterialValue('checkpoint_pointer', 'Value', map_range(0, 130, 1, 0.3, getDistanceBetweenObjects('car_body', 'checkpoint')));
  }
});

detectCollision('car_body', 'checkpoint', function() {
  if (checkpoint_touch_start == false) {
    playSound(loadMedia_WebAudio('./sounds/checkpoint.mp3'), false);
    if (current_checkpoint < 17) {
      current_checkpoint = current_checkpoint + 1;
      recalculate_checkpoint();
      snapToObject('checkpoint', next_checkpoint);
    } else if (current_checkpoint == 17) {
      race_started = false;
      playSound(loadMedia_WebAudio('./sounds/you_finished.mp3'), false);
      changeVis('finish', true);
      changeVis('checkpoint', false);
      changeVis('checkpoint_pointer', false);
      snapToObject('minutes_counter_1', 'time_place_2');
      snapToObject('minutes_counter_2', 'time_place_2');
      snapToObject('seconds_couner_1', 'time_place_2');
      snapToObject('seconds_couner_2', 'time_place_2');
      snapToObject('colon', 'time_place_2');
      registerSetTimeout(5, function() {
        changeVis('finish', false);
        changeVis(['minutes_counter_1', 'minutes_counter_2', 'seconds_couner_1', 'seconds_couner_2', 'colon'], false);
        interface_recalc();
        if (featureAvailable('MOBILE') == true) {
          changeVis('double_tap', true);
        } else {
          changeVis('press_r', true);
        }
        press_r = true;
        registerSetTimeout(10, function() {
          changeVis('press_r', false);
        });
      });
    }
    checkpoint_touch_start = true;
  }
}, function() {
  checkpoint_touch_start = false;
});

registerInterval(1, function() {
  if (no_count == false && no_count == false) {
    start_counter = start_counter + 1;
    setMaterialValue('start_counter', 'Value', start_counter);
  }
  if (race_started == true) {
    checkpoint_seconds = checkpoint_seconds + 1;
    if (checkpoint_seconds == 60) {
      checkpoint_seconds = 0;
      checkpoint_minutes = checkpoint_minutes + 1;
    }
    if (checkpoint_seconds == 0) {
      setMaterialValue('seconds_couner_1', 'Value', 0);
      setMaterialValue('seconds_couner_2', 'Value', 0);
    } else if (checkpoint_seconds < 10) {
      setMaterialValue('seconds_couner_2', 'Value', toNumber(String(checkpoint_seconds).slice(-1)));
    } else {
      setMaterialValue('seconds_couner_1', 'Value', toNumber(String(checkpoint_seconds).charAt(0)));
      setMaterialValue('seconds_couner_2', 'Value', toNumber(String(checkpoint_seconds).slice(-1)));
    }
    if (checkpoint_minutes == 0) {
      setMaterialValue('minutes_counter_1', 'Value', 0);
      setMaterialValue('minutes_counter_2', 'Value', 0);
    } else if (checkpoint_minutes < 10) {
      setMaterialValue('minutes_counter_2', 'Value', toNumber(String(checkpoint_minutes).slice(-1)));
    } else {
      setMaterialValue('minutes_counter_1', 'Value', toNumber(String(checkpoint_minutes).charAt(0)));
      setMaterialValue('minutes_counter_2', 'Value', toNumber(String(checkpoint_minutes).slice(-1)));
    }
  }
});

eventHTMLElem('keydown', ['DOCUMENT'], false, function(event) {
  if (getEventProperty('code', event) == 'KeyR' && press_r == true) {
    press_r_or_bouble_tap();
  }
});

registerOnClick('double_tap', false, true, [0,1,2], function() {
  if (press_r == true) {
    press_r_or_bouble_tap();
    changeVis('double_tap', false);
  }
}, function() {});

/* First Finger Speed Controll */


touch_1_busy = false;
maxBreakingForce_multiplier = 0;
addHTMLElement('div', 'move_indicator', 'TO', ['CONTAINER'], false);
setHTMLElemStyle('width', '60px', 'move_indicator', false);
setHTMLElemStyle('position', 'fixed', 'move_indicator', false);
setHTMLElemStyle('marginLeft', '-30px', 'move_indicator', false);
setHTMLElemStyle('display', 'none', 'move_indicator', false);
setHTMLElemStyle('borderRadius', '30px', 'move_indicator', false);
eventHTMLElem('touchstart', ['WINDOW'], false, function(event) {
  if (game_started == true) {
    if (getEventProperty('touches[0].pageX', event) < getHTMLElemAttribute('innerWidth', ['WINDOW'], false) / 2) {
      if (getEventProperty('touches.length', event) == 1) {
        touch_1_busy = true;
        touch_1_base_y = getEventProperty('touches[0].pageY', event);
        setHTMLElemStyle('left', String(getEventProperty('touches[0].pageX', event)) + 'px', 'move_indicator', false);
      }
    }
  }
});
eventHTMLElem('touchmove', ['WINDOW'], false, function(event) {
  if (game_started == true) {
    if (getEventProperty('touches[0].pageX', event) < getHTMLElemAttribute('innerWidth', ['WINDOW'], false) / 2) {
      touch_1_busy = true;
      touch_1_y_length = touch_1_base_y - getEventProperty('touches[0].pageY', event);
      if (touch_1_y_length < 0) {
        maxBreakingForce_multiplier = map_range(1, 100, 0, 1, Math.abs(touch_1_y_length));
        maxBreakingForce = map_range(0.01, 18, 60, 5, summ_damage) * maxBreakingForce_multiplier;
        dictSet(actions, 'braking', true);
        dictSet(actions, 'acceleration', false);
        setHTMLElemStyle('display', 'block', 'move_indicator', false);
        setHTMLElemStyle('background', 'linear-gradient(0deg, rgba(255,111,0,1) 0%, rgba(255,218,0,0) 100%)', 'move_indicator', false);
        setHTMLElemStyle('height', String(Math.abs(touch_1_base_y - getEventProperty('touches[0].pageY', event)) + 60) + 'px', 'move_indicator', false);
        setHTMLElemStyle('bottom', 'auto', 'move_indicator', false);
        setHTMLElemStyle('top', String(touch_1_base_y) + 'px', 'move_indicator', false);
        setHTMLElemStyle('marginTop', '-30px', 'move_indicator', false);
        setHTMLElemStyle('marginBottom', '0px', 'move_indicator', false);
      } else if (touch_1_y_length > 0) {
        dictSet(actions, 'acceleration', true);
        dictSet(actions, 'braking', false);
        setHTMLElemStyle('display', 'block', 'move_indicator', false);
        setHTMLElemStyle('background', 'linear-gradient(180deg, rgba(255,111,0,1) 0%, rgba(255,218,0,0) 100%)', 'move_indicator', false);
        setHTMLElemStyle('height', String(Math.abs(touch_1_base_y - getEventProperty('touches[0].pageY', event)) + 60) + 'px', 'move_indicator', false);
        setHTMLElemStyle('top', 'auto', 'move_indicator', false);
        setHTMLElemStyle('bottom', String(getHTMLElemAttribute('innerHeight', ['WINDOW'], false) - touch_1_base_y) + 'px', 'move_indicator', false);
        setHTMLElemStyle('marginBottom', '-30px', 'move_indicator', false);
        setHTMLElemStyle('marginTop', '0px', 'move_indicator', false);
      }
    }
  }
});

/* Second Finger Rotation Controll */


addHTMLElement('div', 'rotate_indicator', 'TO', ['CONTAINER'], false);
setHTMLElemStyle('height', '60px', 'rotate_indicator', false);
setHTMLElemStyle('position', 'fixed', 'rotate_indicator', false);
setHTMLElemStyle('marginTop', '-30px', 'rotate_indicator', false);
setHTMLElemStyle('display', 'none', 'rotate_indicator', false);
setHTMLElemStyle('borderRadius', '30px', 'rotate_indicator', false);
setHTMLElemStyle('backgroundColor', 'blue', 'rotate_indicator', false);
eventHTMLElem('touchstart', ['WINDOW'], false, function(event) {
  if (game_started == true) {
    if (getEventProperty('touches.length', event) == 2) {
      if (getEventProperty('touches[1].pageX', event) > getHTMLElemAttribute('innerWidth', ['WINDOW'], false) / 2) {
        touch_2_base_x = getEventProperty('touches[1].pageX', event);
        setHTMLElemStyle('top', String(getEventProperty('touches[1].pageY', event)) + 'px', 'rotate_indicator', false);
      }
    }
  }
});
eventHTMLElem('touchmove', ['WINDOW'], false, function(event) {
  if (game_started == true) {
    if (getEventProperty('touches.length', event) == 2) {
      if (getEventProperty('touches[1].pageX', event) > getHTMLElemAttribute('innerWidth', ['WINDOW'], false) / 2) {
        touch_2_x_length = touch_2_base_x - getEventProperty('touches[1].pageX', event);
        if (touch_2_x_length > 0) {
          steeringIncrement_multiplier = map_range(0, 100, 0.1, 1, Math.abs(touch_2_x_length));
          dictSet(actions, 'left', true);
          dictSet(actions, 'right', false);
          moving_side = 'left';
          setHTMLElemStyle('display', 'block', 'rotate_indicator', false);
          setHTMLElemStyle('background', 'linear-gradient(90deg, rgba(141,180,76,1) 0%, rgba(203,221,80,0) 100%)', 'rotate_indicator', false);
          setHTMLElemStyle('width', String(Math.abs(touch_2_x_length) + 60) + 'px', 'rotate_indicator', false);
          setHTMLElemStyle('right', String(getHTMLElemAttribute('innerWidth', ['WINDOW'], false) - touch_2_base_x) + 'px', 'rotate_indicator', false);
          setHTMLElemStyle('left', 'auto', 'rotate_indicator', false);
          setHTMLElemStyle('marginRight', '-30px', 'rotate_indicator', false);
          setHTMLElemStyle('marginLeft', '0px', 'rotate_indicator', false);
        } else if (touch_2_x_length < 0) {
          steeringIncrement_multiplier = map_range(0, 80, 0.1, 1, Math.abs(touch_2_x_length));
          dictSet(actions, 'right', true);
          dictSet(actions, 'left', false);
          moving_side = 'right';
          setHTMLElemStyle('display', 'block', 'rotate_indicator', false);
          setHTMLElemStyle('background', 'linear-gradient(270deg, rgba(141,180,76,1) 0%, rgba(203,221,80,0) 100%)', 'rotate_indicator', false);
          setHTMLElemStyle('width', String(Math.abs(touch_2_x_length) + 60) + 'px', 'rotate_indicator', false);
          setHTMLElemStyle('left', String(touch_2_base_x) + 'px', 'rotate_indicator', false);
          setHTMLElemStyle('right', 'auto', 'rotate_indicator', false);
          setHTMLElemStyle('marginLeft', '-30px', 'rotate_indicator', false);
          setHTMLElemStyle('marginRight', '0px', 'rotate_indicator', false);
        }
      }
    }
  }
});

/* First Finger Rotation Controll */


mono_rotate_on = false;
eventHTMLElem('touchstart', ['WINDOW'], false, function(event) {
  if (game_started == true) {
    if (getEventProperty('touches[0].pageX', event) > getHTMLElemAttribute('innerWidth', ['WINDOW'], false) / 2) {
      if (car_speed > 0 && touch_1_busy == false) {
        touch_1_base_x = getEventProperty('touches[0].pageX', event);
        setHTMLElemStyle('top', String(getEventProperty('touches[0].pageY', event)) + 'px', 'rotate_indicator', false);
        mono_rotate_on = true;
      }
    }
  }
});
eventHTMLElem('touchmove', ['WINDOW'], false, function(event) {
  if (game_started == true) {
    if (getEventProperty('touches[0].pageX', event) > getHTMLElemAttribute('innerWidth', ['WINDOW'], false) / 2) {
      if (car_speed > 0 && touch_1_busy == false) {
        mono_rotate_on = true;
        touch_1_x_length = touch_1_base_x - getEventProperty('touches[0].pageX', event);
        if (touch_1_x_length > 0) {
          steeringIncrement_multiplier = map_range(0, 100, 0.1, 1, Math.abs(touch_1_x_length));
          dictSet(actions, 'left', true);
          dictSet(actions, 'right', false);
          moving_side = 'left';
          setHTMLElemStyle('display', 'block', 'rotate_indicator', false);
          setHTMLElemStyle('background', 'linear-gradient(90deg, rgba(141,180,76,1) 0%, rgba(203,221,80,0) 100%)', 'rotate_indicator', false);
          setHTMLElemStyle('width', String(Math.abs(touch_1_x_length) + 60) + 'px', 'rotate_indicator', false);
          setHTMLElemStyle('right', String(getHTMLElemAttribute('innerWidth', ['WINDOW'], false) - touch_1_base_x) + 'px', 'rotate_indicator', false);
          setHTMLElemStyle('left', 'auto', 'rotate_indicator', false);
          setHTMLElemStyle('marginRight', '-30px', 'rotate_indicator', false);
          setHTMLElemStyle('marginLeft', '0px', 'rotate_indicator', false);
        } else if (touch_1_x_length < 0) {
          steeringIncrement_multiplier = map_range(0, 80, 0.1, 1, Math.abs(touch_1_x_length));
          dictSet(actions, 'right', true);
          dictSet(actions, 'left', false);
          moving_side = 'right';
          setHTMLElemStyle('display', 'block', 'rotate_indicator', false);
          setHTMLElemStyle('background', 'linear-gradient(270deg, rgba(141,180,76,1) 0%, rgba(203,221,80,0) 100%)', 'rotate_indicator', false);
          setHTMLElemStyle('width', String(Math.abs(touch_1_x_length) + 60) + 'px', 'rotate_indicator', false);
          setHTMLElemStyle('left', String(touch_1_base_x) + 'px', 'rotate_indicator', false);
          setHTMLElemStyle('right', 'auto', 'rotate_indicator', false);
          setHTMLElemStyle('marginLeft', '-30px', 'rotate_indicator', false);
          setHTMLElemStyle('marginRight', '0px', 'rotate_indicator', false);
        }
      }
    }
  }
});

eventHTMLElem('touchend', ['WINDOW'], false, function(event) {
  if (game_started == true) {
    if (getEventProperty('touches.length', event) == 1) {
      dictSet(actions, 'right', false);
      dictSet(actions, 'left', false);
      moving_side = 'none';
      registerSetTimeout(0.1, function() {
        setHTMLElemStyle('display', 'none', 'rotate_indicator', false);
      });
    } else if (getEventProperty('touches.length', event) == 2) {
    } else {
      dictSet(actions, 'acceleration', false);
      dictSet(actions, 'braking', false);
      touch_1_busy = false;
      moving_side = 'none';
      setHTMLElemStyle('display', 'none', 'move_indicator', false);
      if (mono_rotate_on == true) {
        dictSet(actions, 'right', false);
        dictSet(actions, 'left', false);
        moving_side = 'none';
        registerSetTimeout(0.1, function() {
          setHTMLElemStyle('display', 'none', 'rotate_indicator', false);
        });
        mono_rotate_on = false;
      }
    }
  }
});

track_1 = loadMedia_HTML5('./music/track_1.mp3');
track_2 = loadMedia_HTML5('./music/track_2.mp3');
track_3 = loadMedia_HTML5('./music/track_3.mp3');
current_track = null;
current_track_number = 0;
volume(track_1, 0.1);
volume(track_2, 0.1);
volume(track_3, 0.1);

registerEveryFrame(function() {
  if (isSoundPlaying(current_track) == false && game_started == true) {
    change_track();
  }
});



} // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
