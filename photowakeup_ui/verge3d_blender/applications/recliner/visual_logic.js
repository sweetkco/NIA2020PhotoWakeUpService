/**
 * Generated by Verge3D Puzzles v.3.4.0
 * Fri Nov 13 2020 20:15:33 GMT+0300 (Moscow Standard Time)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function() {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.objClickInfo = [];
_pGlob.pickedObject = '';
_pGlob.objHoverInfo = [];
_pGlob.hoveredObject = '';
_pGlob.objMovementInfos = {};
_pGlob.objDragOverCallbacks = [];
_pGlob.objDragOverInfoByBlock = {}
_pGlob.dragMoveOrigins = {};
_pGlob.dragScaleOrigins = {};
_pGlob.mediaElements = {};
_pGlob.loadedFiles = {};
_pGlob.loadedFile = '';
_pGlob.promiseValue = '';
_pGlob.animMixerCallbacks = [];
_pGlob.arHitPoint = new v3d.Vector3(0, 0, 0);
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.animateParamUpdate = null;
_pGlob.openedFile = '';
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.gamepadIndex = 0;

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster();
_pGlob.intervals = {};

var _pPhysics = {};

_pPhysics.tickCallbacks = [];
_pPhysics.syncList = [];
_pPhysics.consList = [];

// internal info
_pPhysics.collisionData = [];

// goes to collision callback
_pPhysics.collisionInfo = {
    objectA: '',
    objectB: '',
    distance: 0,
    positionOnA: [0, 0, 0],
    positionOnB: [0, 0, 0],
    normalOnB: [0, 0, 0]
};

var _noWebAudioReported = false;

var PL = v3d.PL = v3d.PL || {};

// a more readable alias for PL (stands for "Puzzle Logic")
v3d.puzzles = PL;

PL.procedures = PL.procedures || {};

_pGlob.wooProductInfo = {};

PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    var PROC = {
    
};


    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {
initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["check_total_price"] = check_total_price;
this.procedures["number_to_price"] = number_to_price;
this.procedures["pricelist_read"] = pricelist_read;
this.procedures["item_quantity_changing"] = item_quantity_changing;

var PROC = {
    "check_total_price": check_total_price,
    "number_to_price": number_to_price,
    "pricelist_read": pricelist_read,
    "item_quantity_changing": item_quantity_changing,
};

var input_number, row_number, item_quantity_id, list_id, add_or_sub, total_price, pricelist, total_items_in_basket, recliner_unfolded, shopping_cart, animated_parts, shopping_cart_list_position, current_item, reclainer_parts;


// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// getHTMLElemAttribute puzzle
function getHTMLElemAttribute(attr, id, isParent) {
    var elem = getElement(id, isParent);
    return elem ? elem[attr]: '';
}



// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if (attr === 'style') {
            // NOTE: setting an attribute 'style' instead of a property 'style'
            // fixes IE11 worng behavior
            elem.setAttribute(attr, value);
        } else {
            elem[attr] = value;
        }
    }
}


// Describe this function...
function check_total_price() {
  total_price = String(getHTMLElemAttribute('innerHTML', 'item_quantity_1', true) * pricelist[0][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_2', true) * pricelist[1][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_3', true) * pricelist[2][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_4', true) * pricelist[3][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_5', true) * pricelist[4][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_6', true) * pricelist[4][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_7', true) * pricelist[4][2]);
  if (number_to_price(total_price) != '$,0.00') {
    setHTMLElemAttribute('innerHTML', number_to_price(total_price), 'total_price', true);
  } else {
    setHTMLElemAttribute('innerHTML', '$0.00', 'total_price', true);
  }
}

// Describe this function...
function number_to_price(input_number) {
  return ['$',input_number.slice(0, input_number.length - 3),',',input_number.slice(input_number.length - 3, input_number.length - 0),'.00'].join('');
}

// Describe this function...
function pricelist_read(row_number) {
  setHTMLElemAttribute('innerHTML', pricelist[row_number][0], 'item_name', true);
  setHTMLElemAttribute('innerHTML', 'ITEM# - ' + String(pricelist[row_number][1]), 'item_number', true);
  setHTMLElemAttribute('innerHTML', number_to_price(pricelist[row_number][2]), 'price_line', true);
  current_item = pricelist[row_number][0];
}


// convertToNumber puzzle
function toNumber(text) {
    var num = Number(text);
    if (isNaN(num))
        num = 0;
    return num;
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}


// Describe this function...
function item_quantity_changing(item_quantity_id, list_id, add_or_sub) {
  if (add_or_sub == 1) {
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', item_quantity_id, true)) + 1, item_quantity_id, true);
    total_items_in_basket = total_items_in_basket + 1;
  } else {
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', item_quantity_id, true)) - 1, item_quantity_id, true);
    total_items_in_basket = total_items_in_basket - 1;
  }
  setHTMLElemAttribute('innerHTML', total_items_in_basket, 'items_in_basket', true);
  if (toNumber(getHTMLElemAttribute('innerHTML', item_quantity_id, true)) == 0) {
    setHTMLElemStyle('display', 'none', list_id, true);
  }
  check_total_price();
}


// readCSV puzzle
function readCSV(text, delimit, from) {
    return v3d.CSVParser.parse(text,
        {delimiter: delimit, skipinitialrows: from});
}



// loadFile puzzle
function loadFile(url, callback) {

    var files = _pGlob.loadedFiles;

    if (!url || (typeof url != 'string')) {
        _pGlob.loadedFile = '';
        callback();
    } else if (url in files) {
        _pGlob.loadedFile = files[url];
        callback();
    } else {
        var loader = new v3d.FileLoader();
        loader.load(url,
            function(data) {
                _pGlob.loadedFile = data;
                callback();
            },
            function() {},
            function() {
                _pGlob.loadedFile = '';
                callback();
            }
        );
    }
}



// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;
        elem.addEventListener(eventType, callback, false);
    }
}



/**
 * Retreive standard accessible textures for MeshNodeMaterial or MeshStandardMaterial.
 * If "collectSameNameMats" is true then all materials in the scene with the given name will
 * be used for collecting textures, otherwise will be used only the first found material (default behavior).
 */
function matGetEditableTextures(matName, collectSameNameMats) {

    var mats = [];
    if (collectSameNameMats) {
        mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
    } else {
        var firstMat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
        if (firstMat !== null) {
            mats = [firstMat];
        }
    }

    var textures = mats.reduce(function(texArray, mat) {
        var matTextures = [];
        switch (mat.type) {
            case 'MeshNodeMaterial':
                matTextures = Object.values(mat.nodeTextures);
                break;

            case 'MeshStandardMaterial':
                matTextures = [
                    mat.map, mat.lightMap, mat.aoMap, mat.emissiveMap,
                    mat.bumpMap, mat.normalMap, mat.displacementMap,
                    mat.roughnessMap, mat.metalnessMap, mat.alphaMap, mat.envMap
                ]
                break;

            default:
                console.error('matGetEditableTextures: Unknown material type ' + mat.type);
                break;
        }

        Array.prototype.push.apply(texArray, matTextures);
        return texArray;
    }, []);

    return textures.filter(function(elem) {
        // check Texture type exactly
        return elem && (elem.constructor == v3d.Texture
                || elem.constructor == v3d.DataTexture
                || elem.constructor == v3d.VideoTexture);
    });
}



/**
 * Replace accessible textures for MeshNodeMaterial or MeshStandardMaterial
 */
function matReplaceEditableTexture(mat, oldTex, newTex) {

    switch (mat.type) {
        case 'MeshNodeMaterial':
            for (var name in mat.nodeTextures) {
                if (mat.nodeTextures[name] == oldTex) {
                    mat.nodeTextures[name] = newTex;
                }
            }

            break;

        case 'MeshStandardMaterial':

            var texNames = ['map', 'lightMap', 'aoMap', 'emissiveMap',
                            'bumpMap', 'normalMap', 'displacementMap', 'roughnessMap',
                            'metalnessMap', 'alphaMap', 'envMap'];

            texNames.forEach(function(name) {
                if (mat[name] == oldTex) {
                    mat[name] = newTex;
                }
            });

            break;

        default:
            console.error('matReplaceEditableTexture: Unsupported material type ' + mat.type);
            break;
    }

}



// replaceTexture puzzle
function replaceTexture(matName, texName, texUrlOrElem, doCb) {

    var textures = matGetEditableTextures(matName, true).filter(function(elem) {
        return elem.name == texName;
    });

    if (!textures.length)
        return;

    if (texUrlOrElem instanceof Promise) {

        texUrlOrElem.then(function(response) {
           processImageUrl(response);
        }, function(error) {});

    } else if (typeof texUrlOrElem == 'string') {

        processImageUrl(texUrlOrElem);

    /**
     * NOTE: not checking for the MediaHTML5 constructor, because otherwise this
     * puzzle would always provide the code that's not needed most of the time
     */
    } else if (texUrlOrElem instanceof Object && texUrlOrElem.source
            instanceof HTMLVideoElement) {

        processVideo(texUrlOrElem.source);

    } else if (texUrlOrElem instanceof HTMLCanvasElement) {

        processCanvas(texUrlOrElem);

    } else {

        return;

    }

    function processImageUrl(url) {

        var isHDR = (url.search(/\.hdr$/) > 0);

        if (!isHDR) {
            var loader = new v3d.ImageLoader();
            loader.setCrossOrigin('Anonymous');
        } else {
            var loader = new v3d.FileLoader();
            loader.setResponseType('arraybuffer');
        }

        loader.load(url, function(image) {
            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
            var isJPEG = url.search(/\.(jpg|jpeg)$/) > 0 || url.search(/^data\:image\/jpeg/) === 0;

            textures.forEach(function(elem) {

                if (!isHDR) {
                    elem.image = image;
                } else {
                    // parse loaded HDR buffer
                    var rgbeLoader = new v3d.RGBELoader();
                    var texData = rgbeLoader.parse(image);

                    // NOTE: reset params since the texture may be converted to float
                    elem.type = v3d.UnsignedByteType;
                    elem.encoding = v3d.RGBEEncoding;

                    elem.image = {
                        data: texData.data,
                        width: texData.width,
                        height: texData.height
                    }

                    elem.magFilter = v3d.LinearFilter;
                    elem.minFilter = v3d.LinearFilter;
                    elem.generateMipmaps = false;
                    elem.isDataTexture = true;

                }

                elem.format = isJPEG ? v3d.RGBFormat : v3d.RGBAFormat;
                elem.needsUpdate = true;

                // update world material if it is using this texture
                var wMat = appInstance.worldMaterial;
                if (wMat)
                    for (var texName in wMat.nodeTextures)
                        if (wMat.nodeTextures[texName] == elem)
                            appInstance.updateEnvironment(wMat);

            });

            // exec once
            doCb();

        });
    }

    function processVideo(elem) {
        var videoTex = new v3d.VideoTexture(elem);
        videoTex.flipY = false;
        videoTex.name = texName;

        var videoAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            textures.forEach(function(tex) {
                matReplaceEditableTexture(mat, tex, videoTex);
            });

            mat.needsUpdate = true;
            videoAssigned = true;
        });

        if (videoAssigned)
            doCb();

    }

    function processCanvas(elem) {
        var canvasTex = new v3d.CanvasTexture(elem);
        canvasTex.flipY = false;
        canvasTex.name = texName;

        var canvasAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            textures.forEach(function(tex) {
                matReplaceEditableTexture(mat, tex, canvasTex);
            });

            mat.needsUpdate = true;
            canvasAssigned = true;
        });

        if (canvasAssigned) {

            if (v3d.PL) {
                v3d.PL.canvasTextures = v3d.PL.canvasTextures || {};
                v3d.PL.canvasTextures[canvasTex.image.id] = canvasTex;
            }

            doCb();
        }

    }
}



function matGetValues(matName) {

    var mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
    if (!mat)
        return [];

    if (mat.isMeshNodeMaterial)
        return Object.keys(mat.nodeValueMap);
    else if (mat.isMeshStandardMaterial)
        return ['metalness', 'roughness', 'bumpScale', 'emissiveIntensity', 'envMapIntensity'];
    else
        return [];
}



// setMaterialValue puzzle
function setMaterialValue(matName, valName, value) {

    var values = matGetValues(matName);
    if (values.indexOf(valName) < 0)
        return;

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    for (var i = 0; i < mats.length; i++) {
        var mat = mats[i];

        if (mat.isMeshNodeMaterial) {
            var valIdx = mat.nodeValueMap[valName];
            mat.nodeValue[valIdx] = Number(value);
        } else
            mat[valName] = Number(value);

        if (mat === appInstance.worldMaterial)
            appInstance.updateEnvironment(mat);
    }
}



// placeOrder puzzle
function placeOrder(url, title, content, price, makeScreenshot) {

    function doPost(url, params) {
        var form = document.createElement('form');
        form.setAttribute('method', 'post');
        form.setAttribute('action', url);
        form.setAttribute('target', 'v3d_view');

        for (var key in params) {
            var hiddenField = document.createElement('input');
            hiddenField.setAttribute('type', 'hidden');
            hiddenField.setAttribute('name', key);
            hiddenField.setAttribute('value', params[key]);
            form.appendChild(hiddenField);
        }

        document.body.appendChild(form);
        window.open('', 'v3d_view');
        form.submit();
    }

    var orderParams = {
        'v3d_title': title,
        'v3d_content': content,
        'v3d_price': price
    }

    if (makeScreenshot)
        orderParams['v3d_screenshot'] = appInstance.renderer.domElement.toDataURL("image/png");

    doPost(url, orderParams);
}



/**
 * Get a scene that contains the root of the given action.
 */
function getSceneByAction(action) {
    var root = action.getRoot();
    var scene = root.type == "Scene" ? root : null;
    root.traverseAncestors(function(ancObj) {
        if (ancObj.type == "Scene") {
            scene = ancObj;
        }
    });
    return scene;
}



/**
 * Get the current scene's framerate.
 */
function getSceneAnimFrameRate(scene) {
    if (scene && "v3d" in scene.userData && "animFrameRate" in scene.userData.v3d) {
        return scene.userData.v3d.animFrameRate;
    }
    return 24;
}



var initAnimationMixer = function() {

    function onMixerFinished(e) {
        var cb = _pGlob.animMixerCallbacks;
        var found = [];
        for (var i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (var i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished))
            appInstance.mixer.addEventListener('finished', onMixerFinished);
    };

}();



// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, isPlayAnimCompat, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;
        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();
                if (loop && (loop != "AUTO"))
                    action.loop = v3d[loop];
                var scene = getSceneByAction(action);
                var frameRate = getSceneAnimFrameRate(scene);

                // compatibility reasons: deprecated playAnimation puzzles don't
                // change repetitions
                if (!isPlayAnimCompat) {
                    action.repetitions = Infinity;
                }

                var timeScale = Math.abs(parseFloat(speed));
                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                var callbacks = _pGlob.animMixerCallbacks;
                var found = false;

                for (var j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            var callbacks = _pGlob.animMixerCallbacks;
            for (var j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            var scene = getSceneByAction(action);
            var frameRate = getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        }
    }

    for (var i = 0; i < animations.length; i++) {
        var animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}



// socialShareLink puzzle
function socialShareLink(media, title, text) {

    function fixedEncodeURIComponent(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
            return '%' + c.charCodeAt(0).toString(16);
        });
    }

    switch(media) {
    case 'TWITTER':
        return 'https://twitter.com/intent/tweet?url=' +
            fixedEncodeURIComponent(window.location.href) +
            '&text=' + fixedEncodeURIComponent(title);
    case 'FB':
        return 'http://www.facebook.com/sharer.php?u=' +
            fixedEncodeURIComponent(window.location.href);
    case 'REDDIT':
        return 'https://reddit.com/submit?url=' +
            fixedEncodeURIComponent(window.location.href) +
            '&title=' + fixedEncodeURIComponent(title);
    case 'LINKEDIN':
        return 'https://www.linkedin.com/shareArticle?mini=true&url=' +
            fixedEncodeURIComponent(window.location.href) +
             '&title=' + fixedEncodeURIComponent(title) +
             '&summary=' + fixedEncodeURIComponent(text);
    case 'VK':
        return 'http://vk.com/share.php?url=' +
            fixedEncodeURIComponent(window.location.href) +
            '&title=' + fixedEncodeURIComponent(title) +
            '&comment=' + fixedEncodeURIComponent(text);
    case 'WEIBO':
        return 'http://service.weibo.com/share/share.php?url=' +
            fixedEncodeURIComponent(window.location.href) +
            '&title=' + fixedEncodeURIComponent(title);
    }
}



// openWebPage puzzle
function openWebPage(url, mode) {

    if (appInstance && appInstance.controls) {
        appInstance.controls.dispose();
        appInstance.enableControls();
    }

    if (mode == "NEW") {
        window.open(url);
    } else if (mode == "NO_RELOAD") {
        history.pushState('verge3d state', 'verge3d page', url);
    } else {
        var target;
        switch (mode) {
            case "SAME":
                target = "_self";
                break;
            case "TOP":
                target = "_top";
                break;
            case "PARENT":
                target = "_parent";
                break;
        }
        if (typeof window.PE != "undefined") {
            if (window.confirm("Are you sure you want to leave Puzzles?"))
                window.open(url, target);
        } else {
            window.open(url, target);
        }
    }
}



loadFile('ar_pricelist.csv', function() {
  pricelist = readCSV(_pGlob.loadedFile, ',', 1);
  pricelist_read(1);
});
setHTMLElemStyle('visibility', 'hidden', 'fullscreen_button', false);
recliner_unfolded = 0;
animated_parts = ['base', 'recliner_part_8', 'recliner_metal_part_1', 'recliner_metal_part_2', 'recliner_metal_part_3', 'recliner_part_2'];
reclainer_parts = ['recliner_part_1', 'recliner_part_2', 'recliner_part_3', 'recliner_part_4', 'recliner_part_5', 'recliner_part_6', 'recliner_part_7', 'recliner_part_8', 'recliner_part_9', 'recliner_part_10'];
current_item = 'Awesome Recliner AR-RD16';
total_items_in_basket = 0;
shopping_cart = [];

eventHTMLElem('click', 'item_quantity_plus_button_1', true, function(event) {
  item_quantity_changing('item_quantity_1', 'list_1', 1);
});

eventHTMLElem('click', 'item_quantity_minus_button_1', true, function(event) {
  item_quantity_changing('item_quantity_1', 'list_1', -1);
});

eventHTMLElem('click', 'black_leather_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_leather_black_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_leather_black_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_leather_black_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 0);
  pricelist_read(0);
});
eventHTMLElem('click', 'red_leather_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_leather_red_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_leather_red_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_leather_red_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 0);
  pricelist_read(1);
});
eventHTMLElem('click', 'white_leather_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_leather_white_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_leather_white_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_leather_white_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 0);
  pricelist_read(2);
});
eventHTMLElem('click', 'blue_velvet_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_velvet_blue_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_velvet_blue_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_velvet_blue_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 1);
  pricelist_read(3);
});
eventHTMLElem('click', 'green_velvet_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_velvet_green_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_velvet_green_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_velvet_green_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 1);
  pricelist_read(4);
});
eventHTMLElem('click', 'textile_lines_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_textile_lines_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_textile_lines_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_textile_lines_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 0.5);
  pricelist_read(5);
});
eventHTMLElem('click', 'textile_grid_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_textile_grid_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_textile_grid_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_textile_grid_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 0.5);
  pricelist_read(6);
});

eventHTMLElem('click', 'item_quantity_plus_button_2', true, function(event) {
  item_quantity_changing('item_quantity_2', 'list_2', 1);
});

eventHTMLElem('click', 'item_quantity_plus_button_3', true, function(event) {
  item_quantity_changing('item_quantity_3', 'list_3', 1);
});

eventHTMLElem('click', 'item_quantity_plus_button_4', true, function(event) {
  item_quantity_changing('item_quantity_4', 'list_4', 1);
});

eventHTMLElem('click', 'item_quantity_plus_button_5', true, function(event) {
  item_quantity_changing('item_quantity_5', 'list_5', 1);
});

eventHTMLElem('click', 'item_quantity_plus_button_6', true, function(event) {
  item_quantity_changing('item_quantity_6', 'list_6', 1);
});

eventHTMLElem('click', 'item_quantity_plus_button_7', true, function(event) {
  item_quantity_changing('item_quantity_7', 'list_7', 1);
});

eventHTMLElem('click', 'item_quantity_minus_button_2', true, function(event) {
  item_quantity_changing('item_quantity_2', 'list_2', -1);
});

eventHTMLElem('click', 'item_quantity_minus_button_3', true, function(event) {
  item_quantity_changing('item_quantity_3', 'list_3', -1);
});

eventHTMLElem('click', 'item_quantity_minus_button_4', true, function(event) {
  item_quantity_changing('item_quantity_4', 'list_4', -1);
});

eventHTMLElem('click', 'item_quantity_minus_button_5', true, function(event) {
  item_quantity_changing('item_quantity_5', 'list_5', -1);
});

eventHTMLElem('click', 'item_quantity_minus_button_6', true, function(event) {
  item_quantity_changing('item_quantity_6', 'list_6', -1);
});

eventHTMLElem('click', 'item_quantity_minus_button_7', true, function(event) {
  item_quantity_changing('item_quantity_7', 'list_7', -1);
});

eventHTMLElem('click', ['basket_button', 'items_in_basket'], true, function(event) {
  setHTMLElemStyle('display', 'block', 'shopping_cart', true);
});

eventHTMLElem('click', 'checkout_button', true, function(event) {
  if (total_items_in_basket != 0) {
    shopping_cart = [];
    shopping_cart_list_position = 0;
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_1', true)) != 0) {
      shopping_cart[shopping_cart_list_position] = ' ITEM# - 107482 Awesome Recliner AR-BL16, Color: Black Leather, Price: $1,499.00, Quantity of ' + String(getHTMLElemAttribute('innerHTML', 'item_quantity_1', true));
      shopping_cart_list_position = shopping_cart_list_position + 1;
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_2', true)) != 0) {
      shopping_cart[shopping_cart_list_position] = ' ITEM# - 107483 Awesome Recliner AR-RD16, Color: Red Leather, Price: $1,899.00, Quantity of ' + String(getHTMLElemAttribute('innerHTML', 'item_quantity_2', true));
      shopping_cart_list_position = shopping_cart_list_position + 1;
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_3', true)) != 0) {
      shopping_cart[shopping_cart_list_position] = ' ITEM# - 107484 Awesome Recliner AR-BT16, Color: White Leather, Price: $2,099.00, Quantity of ' + String(getHTMLElemAttribute('innerHTML', 'item_quantity_3', true));
      shopping_cart_list_position = shopping_cart_list_position + 1;
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_4', true)) != 0) {
      shopping_cart[shopping_cart_list_position] = ' ITEM# - 107485 Awesome Recliner AR-BU16, Color: Blue Velvet, Price: $1,999.00, Quantity of ' + String(getHTMLElemAttribute('innerHTML', 'item_quantity_4', true));
      shopping_cart_list_position = shopping_cart_list_position + 1;
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_5', true)) != 0) {
      shopping_cart[shopping_cart_list_position] = ' ITEM# - 107486 Awesome Recliner AR-GR16, Color: Green Velvet, Price: $1,799.00, Quantity of ' + String(getHTMLElemAttribute('innerHTML', 'item_quantity_5', true));
      shopping_cart_list_position = shopping_cart_list_position + 1;
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_6', true)) != 0) {
      shopping_cart[shopping_cart_list_position] = ' ITEM# - 107486 Awesome Recliner AR-TL16, Color: Textile Lines, Price: $1,299.00, Quantity of ' + String(getHTMLElemAttribute('innerHTML', 'item_quantity_6', true));
      shopping_cart_list_position = shopping_cart_list_position + 1;
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_7', true)) != 0) {
      shopping_cart[shopping_cart_list_position] = ' ITEM# - 107486 Awesome Recliner AR-TG16, Color: Textile Grid, Price: $1,299.00, Quantity of ' + String(getHTMLElemAttribute('innerHTML', 'item_quantity_7', true));
      shopping_cart_list_position = shopping_cart_list_position + 1;
    }
    placeOrder('https://sandbox.soft8soft.com/order-form/', 'Recliner store', ['Your final order is: ',shopping_cart,'.'].join(''), number_to_price(total_price), false);}
});

eventHTMLElem('click', 'continue_shopping_button', true, function(event) {
  setHTMLElemStyle('display', 'none', 'shopping_cart', true);
});

eventHTMLElem('click', 'add_to_cart_button', true, function(event) {
  total_items_in_basket = total_items_in_basket + 1;
  if (current_item == 'Awesome Recliner AR-BL16') {
    setHTMLElemStyle('display', 'block', 'list_1', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_1', true)) + 1, 'item_quantity_1', true);
  } else if (current_item == 'Awesome Recliner AR-RD16') {
    setHTMLElemStyle('display', 'block', 'list_2', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_2', true)) + 1, 'item_quantity_2', true);
  } else if (current_item == 'Awesome Recliner AR-BT16') {
    setHTMLElemStyle('display', 'block', 'list_3', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_3', true)) + 1, 'item_quantity_3', true);
  } else if (current_item == 'Awesome Recliner AR-BU16') {
    setHTMLElemStyle('display', 'block', 'list_4', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_4', true)) + 1, 'item_quantity_4', true);
  } else if (current_item == 'Awesome Recliner AR-GR16') {
    setHTMLElemStyle('display', 'block', 'list_5', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_5', true)) + 1, 'item_quantity_5', true);
  } else if (current_item == 'Awesome Recliner AR-TL16') {
    setHTMLElemStyle('display', 'block', 'list_6', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_6', true)) + 1, 'item_quantity_6', true);
  } else if (current_item == 'Awesome Recliner AR-TG16') {
    setHTMLElemStyle('display', 'block', 'list_7', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_7', true)) + 1, 'item_quantity_7', true);
  }
  setHTMLElemAttribute('innerHTML', total_items_in_basket, 'items_in_basket', true);
  check_total_price();
});

eventHTMLElem('click', 'change_position_button', true, function(event) {
  if (recliner_unfolded == 0) {
    setHTMLElemStyle('backgroundImage', 'url("images/fold.png")', 'change_position_button', true);

    operateAnimation('PLAY', animated_parts, 1, 75, 'AUTO', 1,
            function() {
      recliner_unfolded = 1;
    }, true, false);

        } else if (recliner_unfolded == 1) {
    setHTMLElemStyle('backgroundImage', 'url("images/unfold.png")', 'change_position_button', true);

    operateAnimation('PLAY', animated_parts, 1, 75, 'AUTO', 1,
            function() {
      recliner_unfolded = 0;
    }, true, true);

        }
});
eventHTMLElem('click', 'facebook_button', true, function(event) {
  openWebPage(socialShareLink('FB', 'Awesome Recliner', 'This stylish and soft recliner has well padded arms and back cushions. It has been designed and manufactured with the highest standards in mind offering an exceptional strength, durability and paramount comfort.'), 'NEW');
});
eventHTMLElem('click', 'twitter_button', true, function(event) {
  openWebPage(socialShareLink('TWITTER', 'Awesome Recliner', 'This stylish and soft recliner has well padded arms and back cushions. It has been designed and manufactured with the highest standards in mind offering an exceptional strength, durability and paramount comfort.'), 'NEW');
});
eventHTMLElem('click', 'linkedin_button', true, function(event) {
  openWebPage(socialShareLink('LINKEDIN', 'Awesome Recliner', 'This stylish and soft recliner has well padded arms and back cushions. It has been designed and manufactured with the highest standards in mind offering an exceptional strength, durability and paramount comfort.'), 'NEW');
});
eventHTMLElem('click', 'google_button', true, function(event) {
  openWebPage(socialShareLink('GPLUS', 'Awesome Recliner', 'This stylish and soft recliner has well padded arms and back cushions. It has been designed and manufactured with the highest standards in mind offering an exceptional strength, durability and paramount comfort.'), 'NEW');
});



} // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
