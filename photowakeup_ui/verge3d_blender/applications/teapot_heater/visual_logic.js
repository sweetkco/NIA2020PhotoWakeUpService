/**
 * Generated by Verge3D Puzzles v.3.4.0
 * Fri Nov 13 2020 20:17:17 GMT+0300 (Moscow Standard Time)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function() {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.objClickInfo = [];
_pGlob.pickedObject = '';
_pGlob.objHoverInfo = [];
_pGlob.hoveredObject = '';
_pGlob.objMovementInfos = {};
_pGlob.objDragOverCallbacks = [];
_pGlob.objDragOverInfoByBlock = {}
_pGlob.dragMoveOrigins = {};
_pGlob.dragScaleOrigins = {};
_pGlob.mediaElements = {};
_pGlob.loadedFiles = {};
_pGlob.loadedFile = '';
_pGlob.promiseValue = '';
_pGlob.animMixerCallbacks = [];
_pGlob.arHitPoint = new v3d.Vector3(0, 0, 0);
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.animateParamUpdate = null;
_pGlob.openedFile = '';
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.gamepadIndex = 0;

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster();
_pGlob.intervals = {};

var _pPhysics = {};

_pPhysics.tickCallbacks = [];
_pPhysics.syncList = [];
_pPhysics.consList = [];

// internal info
_pPhysics.collisionData = [];

// goes to collision callback
_pPhysics.collisionInfo = {
    objectA: '',
    objectB: '',
    distance: 0,
    positionOnA: [0, 0, 0],
    positionOnB: [0, 0, 0],
    normalOnB: [0, 0, 0]
};

var _noWebAudioReported = false;

var PL = v3d.PL = v3d.PL || {};

// a more readable alias for PL (stands for "Puzzle Logic")
v3d.puzzles = PL;

PL.procedures = PL.procedures || {};

_pGlob.wooProductInfo = {};

PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    var PROC = {
    
};


// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if (attr === 'style') {
            // NOTE: setting an attribute 'style' instead of a property 'style'
            // fixes IE11 worng behavior
            elem.setAttribute(attr, value);
        } else {
            elem[attr] = value;
        }
    }
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}




// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = false;


// initPreloader puzzle
_initGlob.output.initOptions.useCustomPreloader = true;
_initGlob.output.initOptions.preloaderStartCb = function() {
    _initGlob.percentage = 0;
    (function() {})();
};
_initGlob.output.initOptions.preloaderProgressCb = function(percentage) {
    _initGlob.percentage = percentage;
    (function() {
  setHTMLElemAttribute('innerHTML', ['Teapot Heater is ',Math.round(_initGlob.percentage),'%',' Loaded'].join(''), 'loading_percantage', true);
  setHTMLElemStyle('height', String(100 - Math.round(_initGlob.percentage)) + '%', 'teapot_hider', true);
})();
};
_initGlob.output.initOptions.preloaderEndCb = function() {
    _initGlob.percentage = 100;
    (function() {
  setHTMLElemStyle('display', 'none', 'progress_bar', true);
})();
};

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {
initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["teapot_buttons_mode"] = teapot_buttons_mode;
this.procedures["button_mouseover/out"] = button_mouseover_out;
this.procedures["heater_buttons_mode"] = heater_buttons_mode;
this.procedures["teapot_tap_action"] = teapot_tap_action;
this.procedures["table_info_opacity"] = table_info_opacity;
this.procedures["open_close_window"] = open_close_window;
this.procedures["gas_cylinder_chosing"] = gas_cylinder_chosing;
this.procedures["key_chosing"] = key_chosing;
this.procedures["tap_chosing"] = tap_chosing;
this.procedures["arrow_chosing"] = arrow_chosing;
this.procedures["gas_cylinder_installed_check"] = gas_cylinder_installed_check;
this.procedures["teapot_boiling_volume_set"] = teapot_boiling_volume_set;
this.procedures["clock_action"] = clock_action;
this.procedures["teapot_boiling_check"] = teapot_boiling_check;
this.procedures["cooking_check"] = cooking_check;
this.procedures["flames_color_check"] = flames_color_check;

var PROC = {
    "teapot_buttons_mode": teapot_buttons_mode,
    "button_mouseover/out": button_mouseover_out,
    "heater_buttons_mode": heater_buttons_mode,
    "teapot_tap_action": teapot_tap_action,
    "table_info_opacity": table_info_opacity,
    "open_close_window": open_close_window,
    "gas_cylinder_chosing": gas_cylinder_chosing,
    "key_chosing": key_chosing,
    "tap_chosing": tap_chosing,
    "arrow_chosing": arrow_chosing,
    "gas_cylinder_installed_check": gas_cylinder_installed_check,
    "teapot_boiling_volume_set": teapot_boiling_volume_set,
    "clock_action": clock_action,
    "teapot_boiling_check": teapot_boiling_check,
    "cooking_check": cooking_check,
    "flames_color_check": flames_color_check,
};

var vfx_sound_multiplier, button_ID, number, action, windows_busy, look_at_point, device_part_list, bucket_animation, window_animation, window_index, indicator_animation, gas_cylinder_animation, gas_cylinder_index, key_animation, key_index, tap_animation, tap_index, arrow_animation, arrow_index, arrow, arrow_speed, windows_distances, windows_opened, gas_cylinder_before, teapot_boiling_valume, info_changed, overall_pressure, windows_installed, distance_opacity, teapot_boiling, drink, about_table_visible, j, teapot_tap_direction, windows_charged, steam_pressure_max, previews_drink, distance_opacity_previews, welcome, environment_muted, teapot_tap_pressure_out, i, teapot_tap_last_frame, gas_cylinder_installed, teapot_mode, device_is_fresh, steam_pressure, clock_is_fresh, cooking_table_opacity, gas_cylinder_after;


// bloom puzzle
function bloom(threshold, strength, radius) {
    appInstance.enablePostprocessing([{
        type: 'bloom',
        threshold: threshold,
        strength: strength,
        radius: radius
    }]);
}



function AudioWebAudio() {
    this.audio = new v3d.Audio(new v3d.AudioListener());

    this._muted = false;
    this._volume = 1;
}

Object.assign(AudioWebAudio.prototype, {

    load: function(url) {
        var scope = this;

        var xhr = new XMLHttpRequest()
        xhr.open('GET', url);
        xhr.responseType = 'arraybuffer';

        xhr.onload = function(e) {
            if (this.status === 200) {
                // new promise-based syntax is not currently supported in Safari
                scope.audio.context.decodeAudioData(this.response, function(decodedData) {
                    scope.audio.setBuffer(decodedData);
                });
            }
        }

        xhr.send();
        return this;
    },

    play: function() {
        if (this.audio.buffer === null) return;
        this.audio.play();
    },

    pause: function() {
        this.audio.pause();
    },

    stop: function() {
        if (this.audio.buffer === null) return;
        this.audio.stop();
    },

    rewind: function() {
        if (this.audio.buffer === null) return;

        var isPlaying = this.audio.isPlaying;
        this.audio.stop();
        if (isPlaying) {
            this.audio.play();
        }
    },

    isPlaying: function() {
        return this.audio.isPlaying;
    },

    setLoop: function(looped) {
        this.audio.setLoop(looped);
    },

    setVolume: function(volume) {
        this._volume = volume;
        if (!this._muted) {
            this.audio.setVolume(volume);
        }
    },

    setMuted: function(muted) {
        this._muted = muted;
        this.audio.setVolume(muted ? 0 : this._volume);
    },

});



// loadMedia puzzle
function loadMedia_WebAudio(url) {
    if (!v3d.Detector.checkWebAudio()) {
        if (!_noWebAudioReported) {
            _noWebAudioReported = true;
            console.warn('v3d.puzzles: Web Audio API not supported');
        }
        return null;
    }

    var elems = _pGlob.mediaElements;
    if (!(url in elems)) {
        elems[url] = new AudioWebAudio().load(url);
    }
    return elems[url];
}



// volume puzzle
function volume(mediaElem, volume) {
    if (!mediaElem)
        return;

    volume = Number(volume);
    if (Number.isNaN(volume)) {
        return;
    }

    mediaElem.setVolume(v3d.Math.clamp(volume, 0.0, 1.0));
}



function MediaHTML5(isVideo) {
    this.source = null;
}

Object.assign(MediaHTML5.prototype, {

    load: function(url, isVideo) {
        if (isVideo) {
            this.source = document.createElement('video');
            this.source.playsInline = true;
            this.source.preload = 'auto';
            this.source.autoload = true;
            this.source.crossOrigin = 'anonymous';
        } else {
            this.source = document.createElement('audio');
        }

        this.source.src = url;
        return this;
    },

    play: function() {
        this.source.play();
    },

    pause: function() {
        this.source.pause();
    },

    stop: function() {
        this.source.pause();
        this.source.currentTime = 0;
    },

    rewind: function() {
        this.source.currentTime = 0;
    },

    isPlaying: function() {
        return this.source.duration > 0 && !this.source.paused;
    },

    setLoop: function(looped) {
        this.source.loop = looped;
    },

    setVolume: function(volume) {
        this.source.volume = volume;
    },

    setMuted: function(muted) {
        this.source.muted = muted;
    },

});



// loadMedia puzzle
function loadMedia_HTML5(url) {

    var elems = _pGlob.mediaElements;
    if (!(url in elems)) {
        elems[url] = new MediaHTML5().load(url);
    }
    return elems[url];
}



// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}


// Describe this function...
function teapot_buttons_mode() {
  setHTMLElemStyle('display', 'block', 'device_part_button_1', true);
  setHTMLElemStyle('display', 'none', 'device_part_button_2', true);
  setHTMLElemStyle('display', 'none', 'device_part_button_3', true);
  setHTMLElemStyle('display', 'none', 'device_part_button_4', true);
}



// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return (obj.type !== "AmbientLight" && obj.name !== ""
            && !(obj.isMesh && obj.isMaterialGeneratedMesh));
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    appInstance.scene.traverse(function(obj) {
        if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
            objFound = obj;
            if (runTime) {
                _pGlob.objCache[objName] = objFound;
            }
        }
    });
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc;
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}




// drawLineObjectHTML and removeLineObjectHTML puzzles
function operateLineObjectHTML(objNames, id, isParent, width, color, offset, op) {
    var elem = getElement(id, isParent);
    if (!elem && (op == "DRAW"))
        return;
    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = getObjectByName(objName);
        if (!obj) continue;

        for (var j = obj.children.length - 1; j >= 0; j--) {
            var child = obj.children[j];
            if (child.isLineHTML) {
                obj.remove(child);
                child.geometry.dispose();
                child.material.dispose();
            }
        }

        if (op == "DRAW") {
            var line = new v3d.LineHTML(new v3d.Color(color).convertSRGBToLinear(),
                    width);
            line.offset = offset;
            line.elemHTML = elem;
            obj.add(line);
        }
    }
}



// outline puzzle
function outline(objNames, doWhat) {
    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;
    if (!appInstance.postprocessing || !appInstance.postprocessing.outlinePass)
        return;
    var outlineArray = appInstance.postprocessing.outlinePass.selectedObjects;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        if (doWhat == "ENABLE") {
            if (outlineArray.indexOf(obj) == -1)
                outlineArray.push(obj);
        } else {
            var index = outlineArray.indexOf(obj);
            if (index > -1)
                outlineArray.splice(index, 1);
        }
    }
}


// Describe this function...
function button_mouseover_out(button_ID, number, action) {
  if (action == 'mouseover') {
    operateLineObjectHTML(device_part_list[info_changed - 1][number], button_ID, true, 3, '#E7BD48', 5, 'DRAW');
    outline(device_part_list[info_changed - 1][number], 'ENABLE');
  } else if (action == 'mouseout') {
    outline(device_part_list[info_changed - 1][number], 'DISABLE');
    for (var j_index in device_part_list) {
      j = device_part_list[j_index];
      for (i = 0; i <= 4; i++) {
        operateLineObjectHTML(j[i], '', false, '', '', '', 'REMOVE');
      }
    }
  }
}

// Describe this function...
function heater_buttons_mode() {
  setHTMLElemStyle('display', 'block', 'device_part_button_1', true);
  setHTMLElemStyle('display', 'block', 'device_part_button_2', true);
  setHTMLElemStyle('display', 'block', 'device_part_button_3', true);
  setHTMLElemStyle('display', 'block', 'device_part_button_4', true);
}


// playSound puzzle
function playSound(mediaElem, loop) {
    if (!mediaElem)
        return;
    mediaElem.setLoop(loop);
    mediaElem.play();
}



/**
 * Get a scene that contains the root of the given action.
 */
function getSceneByAction(action) {
    var root = action.getRoot();
    var scene = root.type == "Scene" ? root : null;
    root.traverseAncestors(function(ancObj) {
        if (ancObj.type == "Scene") {
            scene = ancObj;
        }
    });
    return scene;
}



/**
 * Get the current scene's framerate.
 */
function getSceneAnimFrameRate(scene) {
    if (scene && "v3d" in scene.userData && "animFrameRate" in scene.userData.v3d) {
        return scene.userData.v3d.animFrameRate;
    }
    return 24;
}



var initAnimationMixer = function() {

    function onMixerFinished(e) {
        var cb = _pGlob.animMixerCallbacks;
        var found = [];
        for (var i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (var i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished))
            appInstance.mixer.addEventListener('finished', onMixerFinished);
    };

}();



// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, isPlayAnimCompat, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;
        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();
                if (loop && (loop != "AUTO"))
                    action.loop = v3d[loop];
                var scene = getSceneByAction(action);
                var frameRate = getSceneAnimFrameRate(scene);

                // compatibility reasons: deprecated playAnimation puzzles don't
                // change repetitions
                if (!isPlayAnimCompat) {
                    action.repetitions = Infinity;
                }

                var timeScale = Math.abs(parseFloat(speed));
                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                var callbacks = _pGlob.animMixerCallbacks;
                var found = false;

                for (var j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            var callbacks = _pGlob.animMixerCallbacks;
            for (var j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            var scene = getSceneByAction(action);
            var frameRate = getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        }
    }

    for (var i = 0; i < animations.length; i++) {
        var animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}


// Describe this function...
function teapot_tap_action() {
  if (teapot_tap_direction == 0) {
    playSound(loadMedia_WebAudio('./sounds/teapot_tap_unscrewing.mp3'), false);

    operateAnimation('PLAY', 'teapot_tap', teapot_tap_last_frame - 9, teapot_tap_last_frame, 'AUTO', 1,
            function() {

      operateAnimation('PLAY', 'teapot_holecover', teapot_tap_last_frame - 9, teapot_tap_last_frame, 'AUTO', 1,
              function() {}, true, false);

          teapot_tap_pressure_out = teapot_tap_pressure_out + 10;
      teapot_tap_last_frame = teapot_tap_last_frame + 10;
      if (teapot_tap_pressure_out >= 30) {
        teapot_tap_direction = 1;
      }
    }, true, false);

        } else if (teapot_tap_direction == 1) {
    playSound(loadMedia_WebAudio('./sounds/teapot_tap_unscrewing.mp3'), false);

    operateAnimation('PLAY', 'teapot_tap', teapot_tap_last_frame - 9, teapot_tap_last_frame, 'AUTO', 1,
            function() {

      operateAnimation('PLAY', 'teapot_holecover', teapot_tap_last_frame - 9, teapot_tap_last_frame, 'AUTO', 1,
              function() {}, true, false);

          teapot_tap_pressure_out = teapot_tap_pressure_out - 10;
      teapot_tap_last_frame = teapot_tap_last_frame + 10;
      if (teapot_tap_pressure_out <= 0) {
        teapot_tap_direction = 0;
        teapot_tap_last_frame = 10;
      }
    }, true, false);

        }
}


// distanceBetweenObjects puzzle
function getDistanceBetweenObjects(objName1, objName2) {
    if (!objName1 || !objName2)
        return;
    var obj1 = getObjectByName(objName1);
    var obj2 = getObjectByName(objName2);
    if (!obj1 || !obj2)
        return;
    return obj1.getWorldPosition(_pGlob.vec3Tmp).distanceTo(obj2.getWorldPosition(_pGlob.vec3Tmp2));
}


// Describe this function...
function table_info_opacity(look_at_point) {
  if (getDistanceBetweenObjects('Camera', look_at_point) < 1) {
    distance_opacity = (getDistanceBetweenObjects('Camera', look_at_point) - 0.5) / 0.5;
    if (distance_opacity != distance_opacity_previews) {
      setHTMLElemStyle('opacity', distance_opacity, 'info_table', true);
      setHTMLElemStyle('opacity', distance_opacity, 'device_parts_table', true);
      distance_opacity_previews = distance_opacity;
    }
  } else if (getDistanceBetweenObjects('Camera', look_at_point) >= 0.95) {
    setHTMLElemStyle('opacity', '1', 'info_table', true);
    setHTMLElemStyle('opacity', '1', 'device_parts_table', true);
  } else if (getDistanceBetweenObjects('Camera', look_at_point) <= 0.1) {
    setHTMLElemStyle('opacity', '0', 'info_table', true);
    setHTMLElemStyle('opacity', '0', 'device_parts_table', true);
  }
}


// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function initObjectPicking(callback, eventType, mouseDownUseTouchStart, mouseButtons) {

    var elem = appInstance.renderer.domElement;
    elem.addEventListener(eventType, pickListener);

    if (eventType == 'mousedown') {

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, pickListener);

    } else if (eventType == 'dblclick') {

        var prevTapTime = 0;

        function doubleTapCallback(event) {

            var now = new Date().getTime();
            var timesince = now - prevTapTime;

            if (timesince < 600 && timesince > 0) {

                pickListener(event);
                prevTapTime = 0;
                return;

            }

            prevTapTime = new Date().getTime();
        }

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        elem.addEventListener(touchEventName, doubleTapCallback);
    }

    var raycaster = new v3d.Raycaster();

    function pickListener(event) {
        event.preventDefault();

        var xNorm = 0, yNorm = 0;
        if (event instanceof MouseEvent) {
            if (mouseButtons && mouseButtons.indexOf(event.button) == -1)
                return;
            xNorm = event.offsetX / elem.clientWidth;
            yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
            var rect = elem.getBoundingClientRect();
            xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
            yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(_pGlob.screenCoords, appInstance.camera);
        var objList = [];
        appInstance.scene.traverse(function(obj){objList.push(obj);});
        var intersects = raycaster.intersectObjects(objList);
        callback(intersects, event);
    }
}

function objectsIncludeObj(objNames, testedObjName) {
    if (!testedObjName) return false;

    for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
            return true;
        } else {
            // also check children which are auto-generated for multi-material objects
            var obj = getObjectByName(objNames[i]);
            if (obj && obj.type == "Group") {
                for (var j = 0; j < obj.children.length; j++) {
                    if (testedObjName == obj.children[j].name) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

// utility function used by the whenClicked, whenHovered, whenDraggedOver, and raycast puzzles
function getPickedObjectName(obj) {
    // auto-generated from a multi-material object, use parent name instead
    if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
    } else {
        return obj.name;
    }
}



// whenClicked puzzle
function registerOnClick(objNames, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {
    objNames = retrieveObjectNames(objNames) || [];

    var objNamesFiltered = objNames.filter(function(name) {
        return name;
    });

    // for AR/VR
    _pGlob.objClickInfo.push({
        objNames: objNamesFiltered,
        callbacks: [cbDo, cbIfMissedDo]
    });

    initObjectPicking(function(intersects) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);

            if (objectsIncludeObj(objNamesFiltered, objName)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo();
            }

        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo();
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}


// Describe this function...
function open_close_window(bucket_animation, window_animation, window_index, indicator_animation) {
  if (windows_opened[window_index] == 0 && windows_busy[window_index] == 0) {
    windows_busy[window_index] = 1;
    playSound(loadMedia_WebAudio('./sounds/door_opening.mp3'), false);
    if (windows_charged[window_index] == 1) {

      operateAnimation('PLAY', bucket_animation, 1, 20, 'AUTO', 1,
              function() {
        playSound(loadMedia_WebAudio('./sounds/discharged.mp3'), false);

        operateAnimation('PLAY', indicator_animation, 1, 20, 'AUTO', 1,
                function() {

          operateAnimation('PLAY', window_animation, 1, 75, 'AUTO', 1,
                  function() {
            windows_opened[window_index] = 1;
            windows_charged[window_index] = 0;
            teapot_boiling_check();
            flames_color_check();
            windows_busy[window_index] = 0;
          }, true, false);

              }, true, true);

            }, true, false);

          } else {

      operateAnimation('PLAY', bucket_animation, 1, 20, 'AUTO', 1,
              function() {

        operateAnimation('PLAY', window_animation, 1, 75, 'AUTO', 1,
                function() {
          windows_opened[window_index] = 1;
          teapot_boiling_check();
          flames_color_check();
          windows_busy[window_index] = 0;
        }, true, false);

            }, true, false);

          }
  } else if (windows_opened[window_index] == 1 && windows_busy[window_index] == 0) {
    windows_busy[window_index] = 1;
    playSound(loadMedia_WebAudio('./sounds/door_closing.mp3'), false);

    operateAnimation('PLAY', window_animation, 1, 75, 'AUTO', 1,
            function() {

      operateAnimation('PLAY', bucket_animation, 1, 20, 'AUTO', 1,
              function() {
        if (windows_installed[window_index] != 0) {
          playSound(loadMedia_WebAudio('./sounds/charged.mp3'), false);

          operateAnimation('PLAY', indicator_animation, 1, 20, 'AUTO', 1,
                  function() {
            windows_opened[window_index] = 0;
            windows_charged[window_index] = 1;
            teapot_boiling_check();
            flames_color_check();
            windows_busy[window_index] = 0;
          }, true, false);

              } else if (windows_installed[window_index] == 0) {
          playSound(loadMedia_WebAudio('./sounds/charging_failed.mp3'), false);

          operateAnimation('PLAY', indicator_animation, 1, 5, 'AUTO', 1,
                  function() {

            operateAnimation('PLAY', indicator_animation, 1, 5, 'AUTO', 1,
                    function() {
              windows_charged[window_index] = 0;
              windows_opened[window_index] = 0;
              teapot_boiling_check();
              flames_color_check();
              windows_busy[window_index] = 0;
            }, true, true);

                }, true, false);

              }
      }, true, true);

          }, true, true);

        }
}


// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}


// Describe this function...
function gas_cylinder_chosing(gas_cylinder_animation, gas_cylinder_index) {
  gas_cylinder_before = Math.max.apply(null, [gas_cylinder_installed[0], gas_cylinder_installed[1], gas_cylinder_installed[2]]);
  if (windows_opened[2] == 1) {
    if (gas_cylinder_installed[gas_cylinder_index] == 0) {
      registerSetTimeout(1, function() {
        playSound(loadMedia_WebAudio('./sounds/gas_cylinder_connect.mp3'), false);
      });

      operateAnimation('PLAY', gas_cylinder_animation, 1, 30, 'AUTO', 1,
              function() {
        gas_cylinder_installed[gas_cylinder_index] = 1;
        gas_cylinder_after = Math.max.apply(null, [gas_cylinder_installed[0], gas_cylinder_installed[1], gas_cylinder_installed[2]]);
        if (gas_cylinder_before != gas_cylinder_after) {

          operateAnimation('PLAY', 'steam_arrow_3', null, null, 'LoopOnce', 1,
                  function() {}, true, false);

              }
      }, true, false);

          } else if (gas_cylinder_installed[gas_cylinder_index] == 1) {
      playSound(loadMedia_WebAudio('./sounds/gas_cylinder_disconnect.mp3'), false);

      operateAnimation('PLAY', gas_cylinder_animation, 1, 30, 'AUTO', 1,
              function() {
        gas_cylinder_installed[gas_cylinder_index] = 0;
        gas_cylinder_after = Math.max.apply(null, [gas_cylinder_installed[0], gas_cylinder_installed[1], gas_cylinder_installed[2]]);
        if (gas_cylinder_before != gas_cylinder_after) {

          operateAnimation('PLAY', 'steam_arrow_3', 1, 28, 'AUTO', 1,
                  function() {}, true, true);

              }
      }, true, true);

          }
  }
}

// Describe this function...
function key_chosing(key_animation, key_index) {
  if (windows_opened[3] == 1) {
    if (windows_installed[3] == 0) {
      playSound(loadMedia_WebAudio('./sounds/key_insert.mp3'), false);

      operateAnimation('PLAY', key_animation, 1, 37, 'AUTO', 1,
              function() {
        windows_installed[3] = key_index;
      }, true, false);

          } else if (windows_installed[3] == key_index) {
      playSound(loadMedia_WebAudio('./sounds/key_removing.mp3'), false);

      operateAnimation('PLAY', key_animation, 1, 37, 'AUTO', 1,
              function() {
        windows_installed[3] = 0;
      }, true, true);

          }
  }
}


// pauseSound puzzle
function pauseSound(mediaElem) {
    if (!mediaElem)
        return;
    mediaElem.pause();
}


// Describe this function...
function tap_chosing(tap_animation, tap_index) {
  if (windows_opened[0] == 1) {
    if (windows_installed[0] == 0) {
      playSound(loadMedia_WebAudio('./sounds/tap_screwing.mp3'), false);

      operateAnimation('PLAY', tap_animation, 1, 50, 'AUTO', 1,
              function() {
        windows_installed[0] = tap_index;
        playSound(loadMedia_WebAudio('./sounds/boiler_window_ambient.mp3'), true);

        operateAnimation('PLAY', 'steam_arrow_1', 0, 23, 'AUTO', 1,
                function() {}, true, false);


        operateAnimation('PLAY', 'steam_arrow_2', 0, 23, 'AUTO', 1,
                function() {}, true, false);

            }, true, false);

          } else if (windows_installed[0] == tap_index) {
      playSound(loadMedia_WebAudio('./sounds/tap_unscrewing.mp3'), false);

      operateAnimation('PLAY', tap_animation, 1, 50, 'AUTO', 1,
              function() {
        windows_installed[0] = 0;
      }, true, true);


      operateAnimation('PLAY', 'steam_arrow_1', 0, 23, 'AUTO', 1,
              function() {}, true, true);


      operateAnimation('PLAY', 'steam_arrow_2', 0, 23, 'AUTO', 1,
              function() {
        pauseSound(loadMedia_WebAudio('./sounds/boiler_window_ambient.mp3'));
      }, true, true);

          }
  }
}

// Describe this function...
function arrow_chosing(arrow_animation, arrow_index) {
  if (windows_opened[1] == 1) {
    if (windows_installed[1] == 0) {
      playSound(loadMedia_WebAudio('./sounds/arrow_install.mp3'), false);

      operateAnimation('PLAY', arrow_animation, 1, 30, 'AUTO', 1,
              function() {
        windows_installed[1] = arrow_index;
      }, true, false);

          } else if (windows_installed[1] == arrow_index) {
      playSound(loadMedia_WebAudio('./sounds/arrow_uninstall.mp3'), false);

      operateAnimation('PLAY', arrow_animation, 1, 30, 'AUTO', 1,
              function() {
        windows_installed[1] = 0;
      }, true, true);

          }
  }
}

// Describe this function...
function gas_cylinder_installed_check() {
  if (Math.max.apply(null, [gas_cylinder_installed[0], gas_cylinder_installed[1], gas_cylinder_installed[2]]) == 1) {
    windows_installed[2] = 1;
  } else {
    windows_installed[2] = 0;
  }
}

// Describe this function...
function teapot_boiling_volume_set() {
  teapot_boiling_valume = Math.round(((Math.abs(steam_pressure) - 65) / (100 - 65)) * 100) / 100;
  if (teapot_boiling_valume >= 0) {
    if (teapot_boiling_valume <= 0.3) {
      volume(loadMedia_WebAudio('./sounds/teapot_boiling.mp3'), teapot_boiling_valume);
      console.log(teapot_boiling_valume);
    }
  } else if (Math.round(teapot_boiling_valume) == 0 && teapot_boiling == 0) {
    pauseSound(loadMedia_WebAudio('./sounds/teapot_boiling.mp3'));
  }
}



/**
 * Retrieve coordinate system from the loaded scene
 */
function getCoordSystem() {
    var scene = appInstance.scene;

    if (scene && "v3d" in scene.userData && "coordSystem" in scene.userData.v3d) {
        return scene.userData.v3d.coordSystem;
    } else {
        // COMPAT: <2.17, consider replacing to 'Y_UP_RIGHT' for scenes with unknown origin
        return 'Z_UP_RIGHT';
    }
}


/**
 * Transform coordinates from one space to another
 * Can be used with Vector3 or Euler.
 */
function coordsTransform(coords, from, to, noSignChange) {

    if (from == to)
        return coords;

    var y = coords.y, z = coords.z;

    if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
    } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
    } else {
        console.error('coordsTransform: Unsupported coordinate space');
    }

    return coords;
}


/**
 * Verge3D euler rotation to Blender/Max shortest.
 * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
 *    order) via reversion: XYZ -> ZYX
 * 2) swizzle ZYX->YZX
 * 3) choose the shortest rotation to resemble Blender's behavior
 */
var eulerV3DToBlenderShortest = function() {

    var eulerTmp = new v3d.Euler();
    var eulerTmp2 = new v3d.Euler();
    var vec3Tmp = new v3d.Vector3();

    return function(euler, dest) {

        var eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        var eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        var len = eulerBlender.toVector3(vec3Tmp).lengthSq();
        var lenAlt = eulerBlenderAlt.toVector3(vec3Tmp).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
    }

}();




function RotationInterface() {
    /**
     * For user manipulations use XYZ extrinsic rotations (which
     * are the same as ZYX intrinsic rotations)
     *     - Blender/Max/Maya use extrinsic rotations in the UI
     *     - XYZ is the default option, but could be set from
     *       some order hint if exported
     */
    this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
    this._actualRotation = new v3d.Euler();
}

Object.assign(RotationInterface, {
    initObject: function(obj) {
        if (obj.userData.v3d.puzzles === undefined) {
            obj.userData.v3d.puzzles = {}
        }
        if (obj.userData.v3d.puzzles.rotationInterface === undefined) {
            obj.userData.v3d.puzzles.rotationInterface = new RotationInterface();
        }

        var rotUI = obj.userData.v3d.puzzles.rotationInterface;
        rotUI.updateFromObject(obj);
        return rotUI;
    }
});

Object.assign(RotationInterface.prototype, {

    updateFromObject: function(obj) {
        var SYNC_ROT_EPS = 1e-8;

        if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
            this._actualRotation.copy(obj.rotation);
            this._updateUserRotFromActualRot();
        }
    },

    getActualRotation: function(euler) {
        return euler.copy(this._actualRotation);
    },

    setUserRotation: function(euler) {
        // don't copy the order, since it's fixed to ZYX for now
        this._userRotation.set(euler.x, euler.y, euler.z);
        this._updateActualRotFromUserRot();
    },

    getUserRotation: function(euler) {
        return euler.copy(this._userRotation);
    },

    _updateUserRotFromActualRot: function() {
        var order = this._userRotation.order;
        this._userRotation.copy(this._actualRotation).reorder(order);
    },

    _updateActualRotFromUserRot: function() {
        var order = this._actualRotation.order;
        this._actualRotation.copy(this._userRotation).reorder(order);
    }

});




// setObjTransform puzzle
function setObjTransform(objNames, mode, x, y, z, offset) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames) return;

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.Math.DEG2RAD);
    }

    var coordSystem = getCoordSystem();

    coordsTransform(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    coordsTransform(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj) continue;

        if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = eulerV3DToBlenderShortest(obj.rotation, _pGlob.eulerTmp);
            coordsTransform(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}


// Describe this function...
function clock_action(arrow, arrow_speed) {
  if (drink == 'Nothing' || drink == 'Hot Water' || drink == 'Warm Water' || drink == 'Cold Water') {
    setObjTransform(arrow, 'rotation', arrow_speed, '', '', true);
  } else if (drink == 'Warm Water') {
    setObjTransform(arrow, 'rotation', arrow_speed, '', '', true);
  } else if (drink == 'Cocoa') {
    setObjTransform(arrow, 'rotation', 110, '', '', false);
  } else if (drink == 'Instant Noodles') {
    setObjTransform(arrow, 'rotation', 53, '', '', false);
  } else if (drink == 'Green Tea') {
    setObjTransform(arrow, 'rotation', 200, '', '', false);
  } else if (drink == 'Coffee') {
    setObjTransform(arrow, 'rotation', 147, '', '', false);
  } else if (drink == 'Black Tea') {
    setObjTransform(arrow, 'rotation', 100, '', '', false);
  } else if (drink == 'Hot Chocolate') {
    setObjTransform(arrow, 'rotation', 50, '', '', false);
  }
}

// Describe this function...
function teapot_boiling_check() {
  if (windows_charged[0] != 0 && windows_charged[2] != 0) {
    teapot_boiling = 1;
    playSound(loadMedia_WebAudio('./sounds/teapot_boiling.mp3'), true);
  } else if (windows_charged[0] == 0 || windows_charged[2] == 0) {
    teapot_boiling = 0;
  }
  if (windows_installed[0] == 1) {
    steam_pressure_max = 100;
  } else if (windows_installed[0] == 2) {
    steam_pressure_max = 120;
  } else if (windows_installed[0] == 3) {
    steam_pressure_max = 140;
  }
}


// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if (attr === 'style') {
            // NOTE: setting an attribute 'style' instead of a property 'style'
            // fixes IE11 worng behavior
            elem.setAttribute(attr, value);
        } else {
            elem[attr] = value;
        }
    }
}


// Describe this function...
function cooking_check() {
  if (Math.round(Math.abs(steam_pressure)) < 25) {
    drink = 'Cold Water';
  } else if (Math.round(Math.abs(steam_pressure)) >= 25 && Math.round(Math.abs(steam_pressure)) < 45) {
    drink = 'Warm Water';
  } else if (Math.round(Math.abs(steam_pressure)) >= 45 && Math.round(Math.abs(steam_pressure)) < 65) {
    drink = 'Hot Water';
  } else if (Math.round(Math.abs(steam_pressure)) >= 65 && Math.round(Math.abs(steam_pressure)) < 75) {
    drink = 'Cocoa';
  } else if (Math.round(Math.abs(steam_pressure)) >= 75 && Math.round(Math.abs(steam_pressure)) < 85) {
    drink = 'Instant Noodles';
  } else if (Math.round(Math.abs(steam_pressure)) >= 85 && Math.round(Math.abs(steam_pressure)) < 95) {
    drink = 'Green Tea';
  } else if (Math.round(Math.abs(steam_pressure)) >= 95 && Math.round(Math.abs(steam_pressure)) < 105) {
    drink = 'Coffee';
  } else if (Math.round(Math.abs(steam_pressure)) >= 105 && Math.round(Math.abs(steam_pressure)) < 115) {
    drink = 'Black Tea';
  } else if (Math.round(Math.abs(steam_pressure)) >= 115) {
    drink = 'Hot Chocolate';
  }
  if (drink != previews_drink) {
    if (drink == 'Cold Water') {
      setHTMLElemAttribute('src', 'images/warm_water.png', 'coocking_image', true);
      setHTMLElemAttribute('innerHTML', '', 'coocking_text', true);
    } else if (drink == 'Warm Water') {
      setHTMLElemAttribute('src', 'images/warm_water.png', 'coocking_image', true);
      setHTMLElemAttribute('innerHTML', '', 'coocking_text', true);
    } else if (drink == 'Hot Water') {
      setHTMLElemAttribute('src', 'images/warm_water.png', 'coocking_image', true);
      setHTMLElemAttribute('innerHTML', '', 'coocking_text', true);
    } else if (drink == 'Cocoa') {
      setHTMLElemAttribute('src', 'images/cocoa.png', 'coocking_image', true);
      setHTMLElemAttribute('innerHTML', 'is ready!', 'coocking_text', true);
    } else if (drink == 'Instant Noodles') {
      setHTMLElemAttribute('src', 'images/instant_noodles.png', 'coocking_image', true);
      setHTMLElemAttribute('innerHTML', 'is ready! Doshirak?', 'coocking_text', true);
    } else if (drink == 'Green Tea') {
      setHTMLElemAttribute('src', 'images/green_tea.png', 'coocking_image', true);
      setHTMLElemAttribute('innerHTML', 'is ready!', 'coocking_text', true);
    } else if (drink == 'Coffee') {
      setHTMLElemAttribute('src', 'images/coffee.png', 'coocking_image', true);
      setHTMLElemAttribute('innerHTML', 'is ready!', 'coocking_text', true);
    } else if (drink == 'Black Tea') {
      setHTMLElemAttribute('src', 'images/black_tea.png', 'coocking_image', true);
      setHTMLElemAttribute('innerHTML', 'is ready!', 'coocking_text', true);
    } else if (drink == 'Hot Chocolate') {
      setHTMLElemAttribute('src', 'images/hot_chocolate.png', 'coocking_image', true);
      setHTMLElemAttribute('innerHTML', 'is ready and very hot!', 'coocking_text', true);
    }
    setHTMLElemAttribute('innerHTML', drink, 'coocking_title', true);
  }
  previews_drink = drink;
}


/**
 * Obtain a unique name from the given one. Names are tested with the given
 * callback function that should return a boolean "unique" flag. If the given
 * "name" is not considered unique, then "name2" is tested for uniqueness, then
 * "name3" and so on...
 */
function acquireUniqueName(name, isUniqueCb) {
    var uniqueName = name;

    if (isUniqueCb !== undefined) {
        while (!isUniqueCb(uniqueName)) {
            var r = uniqueName.match(/^(.*?)(\d+)$/);
            if (!r) {
                uniqueName += "2";
            } else {
                uniqueName = r[1] + (parseInt(r[2], 10) + 1);
            }
        }
    }

    return uniqueName;
}



/**
 * Check if the given material name is already used by materials on the scene.
 */
function matNameUsed(name) {
    return v3d.SceneUtils.getMaterialByName(appInstance, name) !== null;
}



// assignMaterial puzzle
function assignMat(objNames, matName) {
    objNames = retrieveObjectNames(objNames);
    if (!objNames || !matName)
        return;
    var mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
    if (!mat)
        return;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (obj) {
            var firstSubmesh = obj.resolveMultiMaterial()[0];

            var hasSkinning = firstSubmesh.isSkinnedMesh;
            var influences = firstSubmesh.morphTargetInfluences;
            var hasMorphing = influences !== undefined && influences.length > 0;

            if (hasSkinning || hasMorphing) {
                var newMat = mat.clone();
                newMat.name = acquireUniqueName(mat.name, function(name) {
                    return !matNameUsed(name);
                });

                if (hasSkinning) {
                    newMat.skinning = true;
                }

                if (hasMorphing) {
                    newMat.morphTargets = true;
                    if (firstSubmesh.geometry.morphAttributes.normal !== undefined) {
                        newMat.morphNormals = true;
                    }
                }

                firstSubmesh.material = newMat;
            } else {
                firstSubmesh.material = mat;
            }
        }
    }
}



// show and hide puzzles
function changeVis(objNames, bool) {
    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
    }
}


// Describe this function...
function flames_color_check() {
  if (gas_cylinder_installed[2] == 0 && gas_cylinder_installed[1] == 0 && gas_cylinder_installed[0] == 1) {
    assignMat('gas_flames', 'gas_flames_blue');
  } else if (gas_cylinder_installed[2] == 0 && gas_cylinder_installed[1] == 1 && gas_cylinder_installed[0] == 0) {
    assignMat('gas_flames', 'gas_flames_green');
  } else if (gas_cylinder_installed[2] == 1 && gas_cylinder_installed[1] == 0 && gas_cylinder_installed[0] == 0) {
    assignMat('gas_flames', 'gas_flames_red');
  } else if (gas_cylinder_installed[2] == 0 && gas_cylinder_installed[1] == 1 && gas_cylinder_installed[0] == 1) {
    assignMat('gas_flames', 'gas_flames_lightblue');
  } else if (gas_cylinder_installed[2] == 1 && gas_cylinder_installed[1] == 1 && gas_cylinder_installed[0] == 0) {
    assignMat('gas_flames', 'gas_flames_yellow');
  } else if (gas_cylinder_installed[2] == 1 && gas_cylinder_installed[1] == 0 && gas_cylinder_installed[0] == 1) {
    assignMat('gas_flames', 'gas_flames_purple');
  } else if (gas_cylinder_installed[2] == 1 && gas_cylinder_installed[1] == 1 && gas_cylinder_installed[0] == 1) {
    assignMat('gas_flames', 'gas_flames_white');
  }
  if (teapot_boiling == 1) {
    changeVis('gas_flames', true);
    playSound(loadMedia_WebAudio('./sounds/gas_fire_loop.mp3'), true);

    operateAnimation('PLAY', 'gas_flames_armature', 1, 10, 'LoopOnce', 1,
            function() {

      operateAnimation('PLAY', 'gas_flames_armature', 10, 30, 'LoopRepeat', 1,
              function() {}, undefined, false);

          }, undefined, false);

        } else if (teapot_boiling == 0) {
    changeVis('gas_flames', false);
    pauseSound(loadMedia_WebAudio('./sounds/gas_fire_loop.mp3'));

    operateAnimation('STOP', 'gas_flames_armature', null, null, 'AUTO', 1,
            function() {}, undefined, false);

        }
}


// initFullscreen puzzle
function initFullscreen(id, isParent, cb_enter, cb_exit, cb_unavail) {
    var elem = getElement(id, isParent);
    if (!elem)
        return;
    var doc = isParent ? parent.document: document;
    if (!(doc.fullscreenEnabled ||
        doc.webkitFullscreenEnabled ||
        doc.mozFullScreenEnabled ||
        doc.msFullscreenEnabled)) {
            cb_unavail();
            return;
    }
    elem.addEventListener("click", function(event) {
        event.stopPropagation();
        if (doc.fullscreenElement ||
            doc.webkitFullscreenElement ||
            doc.mozFullScreenElement ||
            doc.msFullscreenElement) {
            exitFullscreen();
        } else {
            requestFullscreen(doc.body);
        }
    });
    function changeFullscreen() {
        if (doc.fullscreenElement ||
            doc.webkitFullscreenElement ||
            doc.mozFullScreenElement ||
            doc.msFullscreenElement)
            cb_enter();
        else
            cb_exit();
    }
    doc.addEventListener("webkitfullscreenchange", changeFullscreen);
    doc.addEventListener("mozfullscreenchange", changeFullscreen);
    doc.addEventListener("msfullscreenchange", changeFullscreen);
    doc.addEventListener("fullscreenchange", changeFullscreen);
    function requestFullscreen(fselem) {
        if (fselem.requestFullscreen)
            fselem.requestFullscreen();
        else if (fselem.mozRequestFullScreen)
            fselem.mozRequestFullScreen();
        else if (fselem.webkitRequestFullscreen)
            fselem.webkitRequestFullscreen();
        else if (fselem.msRequestFullscreen)
            fselem.msRequestFullscreen();
    }
    function exitFullscreen() {
        if (doc.exitFullscreen)
            doc.exitFullscreen();
        else if (doc.mozCancelFullScreen)
            doc.mozCancelFullScreen();
        else if (doc.webkitExitFullscreen)
            doc.webkitExitFullscreen();
        else if (doc.msExitFullscreen)
            doc.msExitFullscreen();
    }
}



// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;
        elem.addEventListener(eventType, callback, false);
    }
}



// everyFrame puzzle
function registerEveryFrame(callback) {
    if (typeof callback == "function")
        appInstance.renderCallbacks.push(callback);
}



// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = coordsTransform(worldPos, getCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = appInstance.camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = coordsTransform(worldTarget, getCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (appInstance.camera.parent) {
            appInstance.camera.parent.worldToLocal(worldPos);
        }
        appInstance.camera.position.copy(worldPos);
        appInstance.camera.lookAt(worldTarget);
        doSlot();
    }
}



// setInterval puzzle
function registerInterval(timeout, callback) {
    window.setInterval(callback, 1000 * timeout);
}


function mathRandomInt(a, b) {
  if (a > b) {
    // Swap a and b to ensure a is smaller.
    var c = a;
    a = b;
    b = c;
  }
  return Math.floor(Math.random() * (b - a + 1) + a);
}


// whenHovered puzzle
initObjectPicking(function(intersects) {

    var prevHovered = _pGlob.hoveredObject;
    var currHovered = '';

    // search for closest hovered object

    var lastIntersectIndex = Infinity;
    _pGlob.objHoverInfo.forEach(function(el) {
        var maxIntersects = el.xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);

            if (objectsIncludeObj(el.objNames, objName) && i <= lastIntersectIndex) {
                currHovered = objName;
                lastIntersectIndex = i;
            }
        }
    });

    if (prevHovered == currHovered) return;

    // first - all "out" callbacks, then - all "over"
    _pGlob.objHoverInfo.forEach(function(el) {
        if (objectsIncludeObj(el.objNames, prevHovered)) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = prevHovered;
            el.callbacks[1]();
        }
    });

    _pGlob.objHoverInfo.forEach(function(el) {
        if (objectsIncludeObj(el.objNames, currHovered)) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = currHovered;
            el.callbacks[0]();
        }
    });

    _pGlob.hoveredObject = currHovered;
}, 'mousemove', false);



// whenHovered puzzle
function registerOnHover(objNames, xRay, cbOver, cbOut) {
    objNames = retrieveObjectNames(objNames) || [];
    var objNamesFiltered = objNames.filter(function(name) {
        return name;
    });

    _pGlob.objHoverInfo.push({
        objNames: objNamesFiltered,
        callbacks: [cbOver, cbOut],
        xRay: xRay
    });
}



bloom(0.8, 0.3, 0.4);

vfx_sound_multiplier = 2;
volume(loadMedia_WebAudio('./sounds/arrow_install.mp3'), 0.1 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/arrow_uninstall.mp3'), 0.1 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/boiler_window_ambient.mp3'), 0.05 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/arrow_uninstall.mp3'), 0.05 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/charged.mp3'), 0.05 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/charging_failed.mp3'), 0.05 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/clock_gears.mp3'), 0.02 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/device_window_ambient.mp3'), 0.05 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/door_closing.mp3'), 0.3 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/door_opening.mp3'), 0.3 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/gas_cylinder_connect.mp3'), 0.2 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/gas_cylinder_disconnect.mp3'), 0.2 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/gas_fire_loop.mp3'), 0.03 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/key_insert.mp3'), 0.15 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/key_removing.mp3'), 0.15 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/tap_screwing.mp3'), 0.1 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/tap_unscrewing.mp3'), 0.1 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/teapot_tap_unscrewing.mp3'), 0.1 * vfx_sound_multiplier);
volume(loadMedia_WebAudio('./sounds/tick_tack.mp3'), 0.03 * vfx_sound_multiplier);
teapot_boiling_valume = 0;
volume(loadMedia_WebAudio('./sounds/teapot_boiling.mp3'), 0);
volume(loadMedia_HTML5('./sounds/environment_sound.mp3'), 0.05);
environment_muted = 0;

windows_busy = [0, 0, 0, 0];
windows_opened = [0, 0, 0, 0];
windows_installed = [0, 0, 0, 0];
windows_charged = [0, 0, 0, 0];
gas_cylinder_installed = [0, 0, 0];
clock_is_fresh = 1;
device_is_fresh = 1;
gas_cylinder_before = 1;
gas_cylinder_after = 1;
teapot_boiling = 0;
steam_pressure = 0;
steam_pressure_max = 100;
teapot_tap_pressure_out = 0;
teapot_tap_direction = 0;
teapot_tap_last_frame = 10;
arrow_animation = 0;
drink = 'Cold Water';
previews_drink = 'Cold Water';
cooking_table_opacity = 0;

registerOnClick(['ALL_OBJECTS'], false, false, [0,1,2], function() {
  playSound(loadMedia_HTML5('./sounds/environment_sound.mp3'), true);
}, function() {});

device_part_list = [['tap_1', 'tap_2', 'tap_3', 'window_1_bucket'], ['arrow_1', 'arrow_2', 'arrow_3', 'window_2_bucket'], ['gas_cylinder_1', 'gas_cylinder_2', 'gas_cylinder_3', 'window_3_bucket'], ['key_1', 'key_2', 'key_3', 'window_4_bucket'], ['teapot_tap']];

windows_distances = [getDistanceBetweenObjects('Camera', 'steam_window_point'), getDistanceBetweenObjects('Camera', 'clock_window_point'), getDistanceBetweenObjects('Camera', 'gas_window_point'), getDistanceBetweenObjects('Camera', 'gears_window_point')];
info_changed = 0;
about_table_visible = 0;
distance_opacity_previews = 0;
welcome = 1;
teapot_mode = 0;

initFullscreen('fullscreen_button', true, function() {
  setHTMLElemAttribute('src', 'images/fullscreen_down.png', 'fullscreen_button_image', true);
}, function() {
  setHTMLElemAttribute('src', 'images/fullscreen_up.png', 'fullscreen_button_image', true);
}, function() {});

eventHTMLElem('click', 'about_button', true, function(event) {
  if (about_table_visible == 0) {
    setHTMLElemStyle('display', 'block', 'about_table', true);
    about_table_visible = 1;
  } else if (about_table_visible == 1) {
    setHTMLElemStyle('display', 'none', 'about_table', true);
    about_table_visible = 0;
  }
});

registerEveryFrame(function() {
  windows_distances = [getDistanceBetweenObjects('Camera', 'steam_window_point'), getDistanceBetweenObjects('Camera', 'clock_window_point'), getDistanceBetweenObjects('Camera', 'gas_window_point'), getDistanceBetweenObjects('Camera', 'gears_window_point')];
  if (teapot_mode != 1) {
    if (windows_distances[0] <= 0.7 && info_changed != 1) {
      setHTMLElemAttribute('innerHTML', 'Steam Window', 'device_info_head', true);
      setHTMLElemAttribute('innerHTML', 'This is the steam control window of the teapot heater. It regulates the steam pressure of the gas supply. The higher the gas pressure, the higher the temperature you can reach to boil the water in the teapot. Every tap provides a different amount of the pressure.', 'device_info_text', true);
      setHTMLElemAttribute('src', 'images/tap_1.png', 'image_1', true);
      setHTMLElemAttribute('src', 'images/tap_2.png', 'image_2', true);
      setHTMLElemAttribute('src', 'images/tap_3.png', 'image_3', true);
      setHTMLElemAttribute('src', 'images/window_bucket.png', 'image_4', true);
      info_changed = 1;
      welcome = 0;
    } else if (windows_distances[1] <= 0.7 && info_changed != 2) {
      setHTMLElemAttribute('innerHTML', 'Clock Window', 'device_info_head', true);
      setHTMLElemAttribute('innerHTML', 'This is the clock window that shows what type of drink or food you can cook using the water boiled in the teapot. The arrows serve no other purpose than for pure cosmetic effect, just allowing you to customize the look of the clock to your own taste.', 'device_info_text', true);
      setHTMLElemAttribute('src', 'images/arrow_1.png', 'image_1', true);
      setHTMLElemAttribute('src', 'images/arrow_2.png', 'image_2', true);
      setHTMLElemAttribute('src', 'images/arrow_3.png', 'image_3', true);
      setHTMLElemAttribute('src', 'images/window_bucket.png', 'image_4', true);
      info_changed = 2;
      welcome = 0;
    } else if (windows_distances[2] <= 0.7 && info_changed != 3) {
      setHTMLElemAttribute('innerHTML', 'Gas Window', 'device_info_head', true);
      setHTMLElemAttribute('innerHTML', 'This is the gas window that provides gas supply to the burner of the heater. Here you can connect gas cylinders to the heater gas pipes. By combining three different types of cylinders you can control the color of flames. It does not affect the heating of the teapot.', 'device_info_text', true);
      setHTMLElemAttribute('src', 'images/cylinder_1.png', 'image_1', true);
      setHTMLElemAttribute('src', 'images/cylinder_2.png', 'image_2', true);
      setHTMLElemAttribute('src', 'images/cylinder_3.png', 'image_3', true);
      setHTMLElemAttribute('src', 'images/window_bucket.png', 'image_4', true);
      info_changed = 3;
      welcome = 0;
    } else if (windows_distances[3] <= 0.7 && info_changed != 4) {
      setHTMLElemAttribute('innerHTML', 'Gears Window', 'device_info_head', true);
      setHTMLElemAttribute('innerHTML', 'This is the gears window that runs and controls the rotation speed of the grill. Rotating grill allows for better observation of the teapot. Choose a key to run the device. Each key enables a different speed.', 'device_info_text', true);
      setHTMLElemAttribute('src', 'images/key_1.png', 'image_1', true);
      setHTMLElemAttribute('src', 'images/key_2.png', 'image_2', true);
      setHTMLElemAttribute('src', 'images/key_3.png', 'image_3', true);
      setHTMLElemAttribute('src', 'images/window_bucket.png', 'image_4', true);
      info_changed = 4;
      welcome = 0;
    }
  } else if (info_changed != 5 && teapot_mode == 1) {
    setHTMLElemAttribute('innerHTML', 'Teapot', 'device_info_head', true);
    setHTMLElemAttribute('innerHTML', 'With this teapot you can boil water in the most convenient and efficient way. It was custom-made out of copper - the best material for cooking and storing hot drinks. Look closer to feel its magic power and beauty!', 'device_info_text', true);
    setHTMLElemAttribute('src', 'images/teapot_tap.png', 'image_1', true);
    welcome = 0;
    info_changed = 5;
  }
  if (welcome == 0) {
    setHTMLElemStyle('display', 'block', 'device_parts_table', true);
  }
  if (teapot_mode == 0) {
    table_info_opacity('look_at_heater_point');
  } else if (teapot_mode == 1) {
    table_info_opacity('look_at_teapot_point');
  }
});

eventHTMLElem('click', 'look_at_teapot_button', true, function(event) {
  tweenCamera('', 'look_at_teapot_point', 1, function() {}, 0);
  teapot_buttons_mode();
  welcome = 0;
  teapot_mode = 1;
});

eventHTMLElem('click', 'mute_button', true, function(event) {
  if (environment_muted == 0) {
    pauseSound(loadMedia_HTML5('./sounds/environment_sound.mp3'));
    environment_muted = 1;
    setHTMLElemAttribute('src', 'images/unmute_button.png', 'mute_button_image', true);
  } else if (environment_muted == 1) {
    playSound(loadMedia_HTML5('./sounds/environment_sound.mp3'), true);
    environment_muted = 0;
    setHTMLElemAttribute('src', 'images/mute_button.png', 'mute_button_image', true);
  }
});

eventHTMLElem('click', 'steam_window_button', true, function(event) {
  tweenCamera('steam_window_point', 'steam_window_look_at', 1, function() {}, 0);
  info_changed = 0;
  registerSetTimeout(0.3, function() {
    heater_buttons_mode();
    teapot_mode = 0;
  });
});

eventHTMLElem('click', 'look_at_heater_button', true, function(event) {
  tweenCamera('', 'look_at_heater_point', 1, function() {}, 0);
  heater_buttons_mode();
  welcome = 0;
  teapot_mode = 0;
});

eventHTMLElem('click', 'device_part_button_1', true, function(event) {
  if (info_changed == 1) {
    tap_chosing('tap_1', 1);
  } else if (info_changed == 2) {
    arrow_chosing('arrow_1', 1);
  } else if (info_changed == 3) {
    gas_cylinder_chosing('gas_cylinder_1', 0);
  } else if (info_changed == 4) {
    key_chosing('key_1', 1);
  } else if (info_changed == 5) {
    teapot_tap_action();
  }
});

eventHTMLElem('click', 'device_part_button_2', true, function(event) {
  if (info_changed == 1) {
    tap_chosing('tap_2', 2);
  } else if (info_changed == 2) {
    arrow_chosing('arrow_2', 2);
  } else if (info_changed == 3) {
    gas_cylinder_chosing('gas_cylinder_2', 1);
  } else if (info_changed == 4) {
    key_chosing('key_2', 2);
  }
});

eventHTMLElem('click', 'device_part_button_3', true, function(event) {
  if (info_changed == 1) {
    tap_chosing('tap_3', 3);
  } else if (info_changed == 2) {
    arrow_chosing('arrow_3', 3);
  } else if (info_changed == 3) {
    gas_cylinder_chosing('gas_cylinder_3', 2);
  } else if (info_changed == 4) {
    key_chosing('key_3', 3);
  }
});

eventHTMLElem('click', 'device_part_button_4', true, function(event) {
  if (info_changed == 1) {
    open_close_window('window_1_bucket', 'window_1', 0, 'indicator_1');
  } else if (info_changed == 2) {
    open_close_window('window_2_bucket', 'window_2', 1, 'indicator_2');
  } else if (info_changed == 3) {
    gas_cylinder_installed_check();
    open_close_window('window_3_bucket', 'window_3', 2, 'indicator_3');
  } else if (info_changed == 4) {
    gas_cylinder_installed_check();
    open_close_window('window_4_bucket', 'window_4', 3, 'indicator_4');
  }
});

eventHTMLElem('click', 'clock_window_button', true, function(event) {
  tweenCamera('clock_window_point', 'clock_window_look_at', 1, function() {}, 0);
  info_changed = 0;
  registerSetTimeout(0.3, function() {
    heater_buttons_mode();
    teapot_mode = 0;
  });
});

eventHTMLElem('click', 'gas_window_button', true, function(event) {
  tweenCamera('gas_window_point', 'gas_window_look_at', 1, function() {}, 0);
  info_changed = 0;
  registerSetTimeout(0.3, function() {
    heater_buttons_mode();
    teapot_mode = 0;
  });
});

eventHTMLElem('mouseover', 'device_part_button_1', true, function(event) {
  button_mouseover_out('device_part_button_1', 0, 'mouseover');
});

eventHTMLElem('mouseover', 'device_part_button_2', true, function(event) {
  button_mouseover_out('device_part_button_2', 1, 'mouseover');
});

eventHTMLElem('mouseover', 'device_part_button_3', true, function(event) {
  button_mouseover_out('device_part_button_3', 2, 'mouseover');
});

eventHTMLElem('click', 'gears_window_button', true, function(event) {
  tweenCamera('gears_window_point', 'gears_window_look_at', 1, function() {}, 0);
  info_changed = 0;
  registerSetTimeout(0.3, function() {
    heater_buttons_mode();
  });
  teapot_mode = 0;
});

eventHTMLElem('mouseover', 'device_part_button_4', true, function(event) {
  button_mouseover_out('device_part_button_4', 3, 'mouseover');
});

eventHTMLElem('mouseout', 'device_part_button_1', true, function(event) {
  button_mouseover_out('device_part_button_1', 0, 'mouseout');
});

eventHTMLElem('mouseout', 'device_part_button_2', true, function(event) {
  button_mouseover_out('device_part_button_2', 1, 'mouseout');
});

eventHTMLElem('mouseout', 'device_part_button_3', true, function(event) {
  button_mouseover_out('device_part_button_3', 2, 'mouseout');
});

eventHTMLElem('mouseout', 'device_part_button_4', true, function(event) {
  button_mouseover_out('device_part_button_4', 3, 'mouseout');
});

registerInterval(1, function() {
  if (windows_charged[3] == 1) {
    if (device_is_fresh == 1) {

      operateAnimation('PLAY', ['gear_1', 'gear_2', 'gear_3', 'gear_4', 'gear_5', 'gear_6', 'steam_pusher'], null, null, 'LoopRepeat', 1,
              function() {}, true, false);

          device_is_fresh = 1;
      playSound(loadMedia_WebAudio('./sounds/device_window_ambient.mp3'), true);
    } else if (device_is_fresh == 0) {

      operateAnimation('RESUME', ['gear_1', 'gear_2', 'gear_3', 'gear_4', 'gear_5', 'gear_6', 'steam_pusher'], null, null, 'AUTO', 1,
              function() {}, undefined, false);

          playSound(loadMedia_WebAudio('./sounds/device_window_ambient.mp3'), true);
    }
  } else if (windows_charged[3] == 0) {

    operateAnimation('PAUSE', ['gear_1', 'gear_2', 'gear_3', 'gear_4', 'gear_5', 'gear_6', 'steam_pusher'], null, null, 'AUTO', 1,
            function() {}, undefined, false);

        pauseSound(loadMedia_WebAudio('./sounds/device_window_ambient.mp3'));
  }
});

registerEveryFrame(function() {
  overall_pressure = steam_pressure_max - teapot_tap_pressure_out;
  if (teapot_boiling == 1) {
    if (steam_pressure >= overall_pressure * -1) {
      steam_pressure = steam_pressure - 0.1;
      setObjTransform('teapot_arrow', 'rotation', '', steam_pressure, '', false);
      if (steam_pressure > overall_pressure + 1 || steam_pressure < overall_pressure - 1) {
        steam_pressure = steam_pressure - mathRandomInt(0.05, 0.1);
      }
      if (cooking_table_opacity <= 1) {
        if (Math.round(cooking_table_opacity) >= 0) {
          setHTMLElemStyle('display', 'Block', 'coocking_table', true);
        }
        cooking_table_opacity = cooking_table_opacity + (100 / overall_pressure) / 100;
        setHTMLElemStyle('opacity', cooking_table_opacity, 'coocking_table', true);
      } else if (Math.round(cooking_table_opacity) >= 1) {
        setHTMLElemStyle('opacity', '1', 'coocking_table', true);
        cooking_table_opacity = 1;
      }
      cooking_check();
      teapot_boiling_volume_set();
    } else if (steam_pressure <= overall_pressure * -1) {
      steam_pressure = steam_pressure + 0.02;
      setObjTransform('teapot_arrow', 'rotation', '', steam_pressure, '', false);
      if (steam_pressure > overall_pressure + 1 || steam_pressure < overall_pressure - 1) {
        steam_pressure = steam_pressure + mathRandomInt(0.5, 0.2);
      }
    }
  } else if (teapot_boiling == 0) {
    if (steam_pressure < 0) {
      steam_pressure = steam_pressure + 0.3;
      setObjTransform('teapot_arrow', 'rotation', '', steam_pressure, '', false);
      teapot_boiling_volume_set();
      cooking_check();
    }
    if (cooking_table_opacity > 0 && drink == 'Cold Water') {
      cooking_table_opacity = cooking_table_opacity - (100 / overall_pressure) / 100;
      setHTMLElemStyle('opacity', cooking_table_opacity, 'coocking_table', true);
    } else if (Math.round(cooking_table_opacity) <= 0) {
      setHTMLElemStyle('opacity', '0', 'coocking_table', true);
      cooking_table_opacity = 0;
      setHTMLElemStyle('display', 'None', 'coocking_table', true);
      drink = 'Nothing';
      previews_drink = 'Nothing';
    }
  }
});

registerInterval(1, function() {
  if (windows_charged[1] == 1) {
    if (windows_installed[1] == 1) {
      clock_action('arrow_1', 6);
    } else if (windows_installed[1] == 2) {
      clock_action('arrow_2', 8);
    } else if (windows_installed[1] == 3) {
      clock_action('arrow_3', 10);
    }
    playSound(loadMedia_WebAudio('./sounds/tick_tack.mp3'), false);
  }
  if (windows_charged[1] == 1) {
    playSound(loadMedia_WebAudio('./sounds/clock_gears.mp3'), true);
    if (clock_is_fresh == 1) {

      operateAnimation('PLAY', ['gear_7', 'gear_8', 'gear_9', 'gear_10'], null, null, 'LoopRepeat', 1,
              function() {}, true, false);

          clock_is_fresh = 0;
    } else if (clock_is_fresh == 0) {

      operateAnimation('RESUME', ['gear_7', 'gear_8', 'gear_9', 'gear_10'], null, null, 'AUTO', 1,
              function() {}, undefined, false);

          }
  } else if (windows_charged[1] == 0) {

    operateAnimation('PAUSE', ['gear_7', 'gear_8', 'gear_9', 'gear_10'], null, null, 'AUTO', 1,
            function() {}, undefined, false);

        pauseSound(loadMedia_WebAudio('./sounds/clock_gears.mp3'));
  }
});

registerEveryFrame(function() {
  if (windows_charged[3] == 1) {
    if (windows_installed[3] == 1) {
      setObjTransform('grid', 'rotation', '', '', appInstance.elapsed * 10, true);
    } else if (windows_installed[3] == 2) {
      setObjTransform('grid', 'rotation', '', '', appInstance.elapsed * 15, true);
    } else if (windows_installed[3] == 3) {
      setObjTransform('grid', 'rotation', '', '', appInstance.elapsed * 20, true);
    }
  }
});

registerOnClick('window_1_bucket', false, false, [0,1,2], function() {
  open_close_window('window_1_bucket', 'window_1', 0, 'indicator_1');
}, function() {});

registerOnHover('window_1_bucket', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('window_1_bucket', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('window_1_bucket', 'DISABLE');
});

registerOnClick('window_2_bucket', false, false, [0,1,2], function() {
  open_close_window('window_2_bucket', 'window_2', 1, 'indicator_2');
}, function() {});

registerOnHover('window_2_bucket', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('window_2_bucket', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('window_2_bucket', 'DISABLE');
});

registerOnHover('tap_1', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('tap_1', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('tap_1', 'DISABLE');
});

registerOnClick('tap_1', false, false, [0,1,2], function() {
  tap_chosing('tap_1', 1);
}, function() {});

registerOnHover('arrow_1', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('arrow_1', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('arrow_1', 'DISABLE');
});

registerOnClick('arrow_1', false, false, [0,1,2], function() {
  arrow_chosing('arrow_1', 1);
}, function() {});

registerOnHover('tap_2', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('tap_2', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('tap_2', 'DISABLE');
});

registerOnClick('tap_2', false, false, [0,1,2], function() {
  tap_chosing('tap_2', 2);
}, function() {});

registerOnClick('arrow_2', false, false, [0,1,2], function() {
  arrow_chosing('arrow_2', 2);
}, function() {});

registerOnHover('arrow_2', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('arrow_2', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('arrow_2', 'DISABLE');
});

registerOnHover('tap_3', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('tap_3', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('tap_3', 'DISABLE');
});

registerOnClick('tap_3', false, false, [0,1,2], function() {
  tap_chosing('tap_3', 3);
}, function() {});

registerOnHover('arrow_3', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('arrow_3', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('arrow_3', 'DISABLE');
});

registerOnClick('arrow_3', false, false, [0,1,2], function() {
  arrow_chosing('arrow_3', 3);
}, function() {});

registerOnClick('window_3_bucket', false, false, [0,1,2], function() {
  gas_cylinder_installed_check();
  open_close_window('window_3_bucket', 'window_3', 2, 'indicator_3');
}, function() {});

registerOnHover('window_3_bucket', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('window_3_bucket', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('window_3_bucket', 'DISABLE');
});

registerOnClick('window_4_bucket', false, false, [0,1,2], function() {
  gas_cylinder_installed_check();
  open_close_window('window_4_bucket', 'window_4', 3, 'indicator_4');
}, function() {});

registerOnHover('window_4_bucket', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('window_4_bucket', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('window_4_bucket', 'DISABLE');
});

registerOnClick('gas_cylinder_1', false, false, [0,1,2], function() {
  gas_cylinder_chosing('gas_cylinder_1', 0);
}, function() {});

registerOnHover('gas_cylinder_1', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('gas_cylinder_1', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('gas_cylinder_1', 'DISABLE');
});

registerOnHover('key_1', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('key_1', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('key_1', 'DISABLE');
});

registerOnClick('key_1', false, false, [0,1,2], function() {
  key_chosing('key_1', 1);
}, function() {});

registerOnClick('gas_cylinder_2', false, false, [0,1,2], function() {
  gas_cylinder_chosing('gas_cylinder_2', 1);
}, function() {});

registerOnHover('gas_cylinder_2', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('gas_cylinder_2', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('gas_cylinder_2', 'DISABLE');
});

registerOnHover('key_2', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('key_2', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('key_2', 'DISABLE');
});

registerOnClick('key_2', false, false, [0,1,2], function() {
  key_chosing('key_2', 2);
}, function() {});

registerOnClick('gas_cylinder_3', false, false, [0,1,2], function() {
  gas_cylinder_chosing('gas_cylinder_3', 2);
}, function() {});

registerOnHover('gas_cylinder_3', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('gas_cylinder_3', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('gas_cylinder_3', 'DISABLE');
});

registerOnClick('key_3', false, false, [0,1,2], function() {
  key_chosing('key_3', 3);
}, function() {});

registerOnHover('key_3', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('key_3', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('key_3', 'DISABLE');
});

registerOnHover('teapot_tap', false, function() {
  setHTMLElemStyle('cursor', 'pointer', 'container', false);
  outline('teapot_tap', 'ENABLE');
}, function() {
  setHTMLElemStyle('cursor', 'default', 'container', false);
  outline('teapot_tap', 'DISABLE');
});

registerOnClick('teapot_tap', false, false, [0,1,2], function() {
  teapot_tap_action();
}, function() {});



} // end of PL.init function

})(); // end of closure

/* ================================ end of code ============================= */
